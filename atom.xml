<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>会飞的鱼</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-20T09:12:56.932Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis集群</title>
    <link href="http://yoursite.com/2019/02/20/redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/02/20/redis集群/</id>
    <published>2019-02-20T08:28:10.000Z</published>
    <updated>2019-02-20T09:12:56.932Z</updated>
    
    <content type="html"><![CDATA[<p>redis 单点、redis主从、redis哨兵sentinel、redis集群cluster配置搭建。</p><a id="more"></a><h3 id="redis单点"><a href="#redis单点" class="headerlink" title="redis单点"></a>redis单点</h3><p>编辑redis.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes   指定后台运行</span><br></pre></td></tr></table></figure><p>配置说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">daemonize：如需要在后台运行，把该项的值改为yes</span><br><span class="line"></span><br><span class="line">　　pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址</span><br><span class="line"></span><br><span class="line">　　<span class="built_in">bind</span>：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</span><br><span class="line"></span><br><span class="line">　　port：监听端口，默认为6379</span><br><span class="line"></span><br><span class="line">　　timeout：设置客户端连接时的超时时间，单位为秒</span><br><span class="line"></span><br><span class="line">　　loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</span><br><span class="line"></span><br><span class="line">　　logfile：配置<span class="built_in">log</span>文件地址，默认使用标准输出，即打印在命令行终端的端口上</span><br><span class="line"></span><br><span class="line">　　database：设置数据库的个数，默认使用的数据库是0</span><br><span class="line"></span><br><span class="line">　　save：设置redis进行数据库镜像的频率</span><br><span class="line"></span><br><span class="line">　　rdbcompression：在进行镜像备份时，是否进行压缩</span><br><span class="line"></span><br><span class="line">dbfilename：镜像备份文件的文件名</span><br><span class="line"></span><br><span class="line">　　dir：数据库镜像备份的文件放置的路径</span><br><span class="line"></span><br><span class="line">　　slaveof：设置该数据库为其他数据库的从数据库</span><br><span class="line"></span><br><span class="line">　　masterauth：当主数据库连接需要密码验证时，在这里设定</span><br><span class="line"></span><br><span class="line">　　requirepass：设置客户端连接后进行任何其他指定前需要使用的密码</span><br><span class="line"></span><br><span class="line">　　maxclients：限制同时连接的客户端数量</span><br><span class="line"></span><br><span class="line">　　maxmemory：设置redis能够使用的最大内存</span><br><span class="line"></span><br><span class="line">　　appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态</span><br><span class="line"></span><br><span class="line">　　appendfsync：设置appendonly.aof文件进行同步的频率</span><br><span class="line"></span><br><span class="line">　　vm_enabled：是否开启虚拟内存支持</span><br><span class="line"></span><br><span class="line">　　vm_swap_file：设置虚拟内存的交换文件的路径</span><br><span class="line"></span><br><span class="line">　　vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</span><br><span class="line"></span><br><span class="line">　　vm_page_size：设置虚拟内存页的大小</span><br><span class="line"></span><br><span class="line">　　vm_pages：设置交换文件的总的page数量</span><br><span class="line"></span><br><span class="line">　　vm_max_thrrads：设置vm IO同时使用的线程数量</span><br></pre></td></tr></table></figure><h3 id="redis主从"><a href="#redis主从" class="headerlink" title="redis主从"></a>redis主从</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-master-slave</span><br><span class="line">cp path/to/redis/conf/redis.conf path/to/redis-master-slave master.conf</span><br><span class="line">cp path/to/redis/conf/redis.conf path/to/redis-master-slave slave.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## master.conf</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">## slave.conf</span></span><br><span class="line">port 6380</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>启动主从redis，打开两个命令窗口执行info</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br></pre></td></tr></table></figure><p>主节点set数据后，可以在从节点get数据，但是在从节点不可以set</p><h3 id="哨兵sentinel"><a href="#哨兵sentinel" class="headerlink" title="哨兵sentinel"></a>哨兵sentinel</h3><p>上面我们介绍了主从，从库作为一个“傀儡”，可以在需要的时候“顶上来”，”接盘“。我们配置的主从是为了”有备无患“，在主redis挂了之后，可以立马切换到从redis上，可能只需要花几分钟的时间，但是仍然是需要人为操作。这个时候redis sentinel 就派上用场了。sentinel 通常翻译成哨兵，就是放哨的，这里它就是用来监控主从节点的健康情况。客户端连接redis主从的时候，先连接 sentinel，sentinel会告诉客户端主redis的地址是多少，然后客户端连接上redis并进行后续的操作。当主节点挂掉的时候，客户端就得不到连接了因而报错了，客户端重新想sentinel询问主master的地址，然后客户端得到了新选举出来的主redis，然后又可以愉快的操作了。</p><p>为了说明sentinel的用处，我们做个试验。配置3个redis（1主2从），1个哨兵。步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-sentinel</span><br><span class="line"><span class="built_in">cd</span> redis-sentinel</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis01.conf</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis02.conf</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis03.conf</span><br><span class="line">touch sentinel.conf</span><br></pre></td></tr></table></figure><p>上我们创建了 3个redis配置文件，1个哨兵配置文件。我们将 redis01设置为master,将redis02，redis03设置为slave。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim redis01.conf</span><br><span class="line">port 63791</span><br><span class="line"></span><br><span class="line">vim redis02.conf</span><br><span class="line">port 63792</span><br><span class="line">slaveof 127.0.0.1 63791</span><br><span class="line"></span><br><span class="line">vim redis03.conf</span><br><span class="line">port 63793</span><br><span class="line">slaveof 127.0.0.1 63791</span><br><span class="line"></span><br><span class="line">vim sentinel.conf</span><br><span class="line">daemonize yes</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 63791 1</span><br></pre></td></tr></table></figure><p>哨兵配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">protected-mode no</span><br><span class="line">pidfile <span class="string">"/usr/local/redis/var/redis-sentinel.pid"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis/data/sentinel"</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">"/usr/local/redis/var/redis-sentinel.log"</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 63791 1</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 18000</span><br><span class="line">sentinel auth-pass mymaster admin</span><br><span class="line">sentinel failover-timeout mymaster 18000</span><br><span class="line">sentinel auth-pass mymaster admin</span><br></pre></td></tr></table></figure><p>mymaster 为主节点名字，可以随便取，后面程序里边连接的时候要用到 127.0.0.1 63793 为主节点的 ip,port 1 后面的数字 1 表示选举主节点的时候，投票数。1表示有一个sentinel同意即可升级为master。</p><p>主节点宕机模拟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始情况下，1主2从</span><br><span class="line"><span class="comment"># +monitor master mymaster 127.0.0.1 63791 quorum 1</span></span><br><span class="line">* +slave slave 127.0.0.1:63792 127.0.0.1 63792 @ mymaster 127.0.0.1 63791</span><br><span class="line">* +slave slave 127.0.0.1:63793 127.0.0.1 63793 @ mymaster 127.0.0.1 63791</span><br><span class="line">发现主挂了，准备 故障转移</span><br><span class="line"><span class="comment"># +try-failover master mymaster 127.0.0.1 63791</span></span><br><span class="line">将主切换到了 63793 即redis03 </span><br><span class="line"><span class="comment"># +switch-master mymaster 127.0.0.1 63791 127.0.0.1 63793</span></span><br></pre></td></tr></table></figure><p>切换异常：30367:X 17 Oct 13:24:11.578 # -failover-abort-not-elected master mymaster 127.0.0.1 63793</p><p>解决：如果redis.conf配置中配置了</p><p>protected-mode yes</p><p>bind 192.168.98.136</p><p>则需要在sentinel 配置文件加上protected-mode no</p><p>否则在sentinel 配置文件加上</p><p>protected-mode yes  </p><p>bind 192.168.98.136</p><h3 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h3><ul><li><p>单个redis并发有限</p></li><li><p>单个redis内存有限，内存太大导致rdb文件过大，同步回复数据会很慢。</p></li></ul><p>所有，我们需要redis cluster 即redis集群。</p><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p><p>Redis 集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li><p>自动分割数据到不同的节点上。</p></li><li><p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p></li></ul><p>因为最小的redis集群，需要至少3个主节点，既然有3个主节点，而一个主节点搭配至少一个从节点，因此至少得6台redis。</p><p>创建redis集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-5.0.3/src/redis-cli --cluster create 127.0.0.1:6371 127.0.0.1:6372 127.0.0.1:6373 127.0.0.1:6374 127.0.0.1:6375 127.0.0.1:6376 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>集群管理界面：Relumin</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis 单点、redis主从、redis哨兵sentinel、redis集群cluster配置搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="redis集群" scheme="http://yoursite.com/tags/redis%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq集群</title>
    <link href="http://yoursite.com/2019/02/20/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/02/20/rabbitmq集群/</id>
    <published>2019-02-20T06:38:10.000Z</published>
    <updated>2019-02-20T09:12:56.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><pre><code>RabbitMQ集群中可以共享user，virtualhosts，queues，exchanges等。但message只会在创建的节点上传输。当message进入A节点的queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。RABBITMQ的集群节点包括内存节点、磁盘节点。内存节点的元数据仅放在内存中，性能比磁盘节点会有所提升。不过，如果在投递message时，打开了message的持久化，那么内存节点的性能只能体现在资源管理上，比如增加或删除队列（queue），虚拟主机（vrtual hosts），交换机（exchange）等，发送和接受message速度同磁盘节点一样。一个集群至少要有一个磁盘节点。</code></pre><a id="more"></a><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><ul><li><p>cookie同步</p><p>同步/var/lib/rabbitmq/erlang.cookie，本文件默认权限400。</p></li><li><p>加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit@tabbitmq1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>查看集群信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>更改节点属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl change_cluster_node_type disc/ram</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>节点退出集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">退出节点服务执行：</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">集群主节点执行：</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@rabbitmq2</span><br></pre></td></tr></table></figure></li><li><p>rabbitmq集群重启</p><p>集群重启时，最后一个挂掉的节点应该第一个重启，如果因特殊原因（比如同时断电），而不知道哪个节点最后一个挂掉。可用以下方法重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl force_boot</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">在其他节点上执行</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">查看cluster状态是否正常（要在所有节点上查询）。</span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>如果有节点没加入集群，可以先退出集群，然后再重新加入集群。上述方法不适合内存节点重启，内存节点重启的时候是会去磁盘节点同步数据，如果磁盘节点没起来，内存节点一直失败。</p></li></ul><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>镜像队列可以同步queue和message，当主queue挂掉，从queue中会有一个变为主queue来接替工作。</p><p>镜像队列是基于普通的集群模式的,所以你还是得先配置普通集群,然后才能设置镜像队列。</p><p>镜像队列设置后，会分一个主节点和多个从节点，如果主节点宕机，从节点会有一个选为主节点，原先的主节点起来后会变为从节点。</p><p>queue和message虽然会存在所有镜像队列中，但客户端读取时不论物理面连接的主节点还是从节点，都是从主节点读取数据，然后主节点再将queue和message的状态同步给从节点，因此多个客户端连接不同的镜像队列不会产生同一message被多次接受的情况。</p><p>#rabbitmqctl set_policy  ha-all “hello” ‘{“ha-mode”:”all”}’</p><p>ha-all 是同步模式，指同步给所有节点，还有另外两种模式ha-exactly表示在指定个数的节点上进行镜像，节点的个数由ha-params指定，ha-nodes表示在指定的节点上进行镜像，节点名称通过ha-params指定；</p><p>hello 是同步的队列名，可以用正则表达式匹配；</p><p>{“ha-mode”:”all”} 表示同步给所有，同步模式的不同，此参数也不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;RabbitMQ集群中可以共享user，virtualhosts，queues，exchanges等。但message只会在创建的节点上传输。当message进入A节点的queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。

RABBITMQ的集群节点包括内存节点、磁盘节点。内存节点的元数据仅放在内存中，性能比磁盘节点会有所提升。不过，如果在投递message时，打开了message的持久化，那么内存节点的性能只能体现在资源管理上，比如增加或删除队列（queue），虚拟主机（vrtual hosts），交换机（exchange）等，发送和接受message速度同磁盘节点一样。一个集群至少要有一个磁盘节点。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="rabbitmq集群" scheme="http://yoursite.com/tags/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA使用</title>
    <link href="http://yoursite.com/2019/02/13/IntellijIDEA%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/13/IntellijIDEA使用/</id>
    <published>2019-02-13T09:27:28.000Z</published>
    <updated>2019-02-13T09:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>关闭自动更新</p><p>Intellij IDEA -&gt; Preferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates 下取消 Automatically check updates for勾选</p></li><li><p>代码编辑器主题风格</p><p>Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Font</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scheme: Darcula</span><br><span class="line">Show only monospaced fonts 设置第一字体，Monaco 不支持中文</span><br><span class="line">    Primary font:Monaco Size:<span class="number">20</span> Line spacing:<span class="number">1.0</span></span><br><span class="line">Secondary font：YaHei Consolas Hybrid  设置第二字体</span><br></pre></td></tr></table></figure></li><li><p>文件编码</p><p>File -&gt; Settings -&gt; Editor -&gt; File Encodings</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Global Encoding:UTF-<span class="number">8</span></span><br><span class="line">Projectt Encoding:UTF-<span class="number">8</span></span><br><span class="line">Default encoding <span class="keyword">for</span> properties files:UTF-<span class="number">8</span></span><br><span class="line">勾选上Transparent native-to-ascii conversion</span><br></pre></td></tr></table></figure></li><li><p>类和方法注视模版</p><p>在File -&gt; Settings -&gt; Editor -&gt; File and Code Templates</p></li><li><p>编码缩进</p><p>Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Code Style -&gt; Erlang</p><p>Use tab character 不要勾选，然后indent设置为4，代表按一个tab为4个空格，并且自动整理格式也是4个空格一缩进。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tab size: <span class="number">4</span> </span><br><span class="line">Indent: <span class="number">4</span></span><br><span class="line">Continuation indent: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>如果要对多个文件进行转换，可以在文件夹上面按右键，然后点击Reformat Code或者选中文件夹按快捷键ctrl+alt+L对多个快捷键整理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;关闭自动更新&lt;/p&gt;
&lt;p&gt;Intellij IDEA -&amp;gt; Preferences -&amp;gt; Appearance &amp;amp; Behavior -&amp;gt; System Settings -&amp;gt; Updates 下取消 Automatica
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>java安装</title>
    <link href="http://yoursite.com/2019/02/13/java%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/02/13/java安装/</id>
    <published>2019-02-13T09:23:39.000Z</published>
    <updated>2019-02-20T06:33:05.355Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>java 1.8 安装</p><p>yum install yum install java-1.8.0-openjdk-devel.x86_64</p></li><li><p>java 环境变量</p><p>CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HOME</span>/bin:<span class="variable">$HOME</span>/.<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>java 1.8 安装</p><p>yum install yum install java-1.8.0-openjdk-devel.x86_64</p></li><li><p>java 环境变量</p><p>CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HOME</span>/bin:<span class="variable">$HOME</span>/.<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>java 安装目录信息</p><p>dt.jar中包含了关于swing的控件对应的图标和BeanInfo.class</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jvm-exports/java</span><br><span class="line">/usr/lib/java</span><br><span class="line">/usr/lib/jvm/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/jre/bin/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/bin/java</span><br><span class="line">/usr/share/java</span><br><span class="line">/usr/bin/java</span><br><span class="line">/var/lib/alternatives/java</span><br><span class="line">/etc/pki/java</span><br><span class="line">/etc/pki/ca-trust/extracted/java</span><br><span class="line">/etc/java</span><br><span class="line">/etc/alternatives/java</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;java 1.8 安装&lt;/p&gt;
&lt;p&gt;yum install yum install java-1.8.0-openjdk-devel.x86_64&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java 环境变量&lt;/p&gt;
&lt;p&gt;CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;variable&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JAVA_HOME=/usr/lib/jvm/java-1.8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLASSPATH=.:&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/lib/tools.jar:&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/lib/dt.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/.&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$PATH&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq知识</title>
    <link href="http://yoursite.com/2019/02/13/rabbitmq%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/13/rabbitmq知识/</id>
    <published>2019-02-13T09:23:39.000Z</published>
    <updated>2019-02-20T09:12:56.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述）</p><ul><li>fanout</li></ul><p>转发消息到所有绑定队列。</p><ul><li>direct</li></ul><p>把消息路由到那些binding key与routing key完全匹配的Queue中。</p><ul><li>headers</li></ul><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><ul><li>topic</li></ul><p>topic类型的Exchange在匹配规则上进行了扩展。</p><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”。</p><p>binding key与routing key一样也是句点号“. ”分隔的字符串。</p><p>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。</p><h3 id="RabbitMQ-RPC"><a href="#RabbitMQ-RPC" class="headerlink" title="RabbitMQ RPC"></a>RabbitMQ RPC</h3><p><img src="https://cdn.www.sojson.com/file/doc/6121174952" alt=""></p><p><a href="http://www.sojson.com/tag_rabbitmq.html" title="RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a> 中实现<code>RPC</code>的机制是：</p><ul><li><p>客户端发送请求（消息）时，在消息的属性（<code>MessageProperties</code>，在<code>AMQP</code>协议中定义了14中<code>properties</code>，这些属性会随着消息一起发送）中设置两个值<code>replyTo</code>（一个<code>Queue</code>名称，用于告诉服务器处理完成后将通知我的消息发送到这个<code>Queue</code>中）和<code>correlationId</code>（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</p></li><li><p>服务器端收到消息并处理</p></li><li><p>服务器端处理完消息后，将生成一条应答消息到<code>replyTo</code>指定的<code>Queue</code>，同时带上<code>correlationId</code>属性</p></li><li><p>客户端之前已订阅<code>replyTo</code>指定的<code>Queue</code>，从中收到服务器的应答消息后，根据其中的<code>correlationId</code>属性分析哪条请求被执行了，根据执行结果进行后续业务处理</p></li></ul><h3 id="RabbitMQ-选型和对比"><a href="#RabbitMQ-选型和对比" class="headerlink" title="RabbitMQ 选型和对比"></a>RabbitMQ 选型和对比</h3><p>1.从社区活跃度</p><p>按照目前网络上的资料，<code>RabbitMQ</code>、<code>activeM</code>、<code>ZeroMQ</code>三者中，综合来看，<code>RabbitMQ</code>是首选。</p><p>2.持久化消息比较</p><p><code>ZeroMq</code>不支持，<code>ActiveMq</code>和<code>RabbitMq</code>都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</p><p>3.综合技术实现</p><p>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。</p><p><code>RabbitMq</code>/<code>Kafka</code>最好，<code>ActiveMq</code>次之，<code>ZeroMq</code>最差。当然<code>ZeroMq</code>也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</p><p> 4.高并发</p><p>毋庸置疑，<code>RabbitMQ</code>最高，原因是它的实现语言是天生具备高并发高可用的<code>erlang</code>语言。</p><p> 5.比较关注的比较，RabbitMQ和 Kafka</p><p><code>RabbitMq</code>比<code>Kafka</code>成熟，在可用性上，稳定性上，可靠性上， <a href="http://www.sojson.com/tag_rabbitmq.html" title="RabbitMq" target="_blank" rel="noopener">RabbitMq</a> 胜于 <a href="http://www.sojson.com/tag_kafka.html" title="Kafka" target="_blank" rel="noopener">Kafka</a> （理论上）。</p><p>另外，<code>Kafka</code>的定位主要在日志等方面， 因为<code>Kafka</code>设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择<code>RabbitMq</code>。</p><h3 id="RabbitMQ-Erlang-Client"><a href="#RabbitMQ-Erlang-Client" class="headerlink" title="RabbitMQ Erlang Client"></a>RabbitMQ Erlang Client</h3><p><a href="http://www.rabbitmq.com/erlang-client.html" title="Amqp Erlang Client" target="_blank" rel="noopener">Amqp Erlang Client</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RabbitMQ简介&quot;&gt;&lt;a href=&quot;#RabbitMQ简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ简介&quot;&gt;&lt;/a&gt;RabbitMQ简介&lt;/h3&gt;&lt;p&gt;RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;p&gt;AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>erlang知识点记录</title>
    <link href="http://yoursite.com/2019/01/08/erlang%20%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/01/08/erlang 知识点记录/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>gen_server:cast和erlang:send()都可以向指定进程发送消息，两者有什么区别？</p><p>gen_server:cast 内部调用erlang:send使用noconnect</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">catch</span> erlang:send(Dest, Msg, [noconnect]) <span class="keyword">of</span></span><br><span class="line">    noconnect -&gt;</span><br><span class="line">        spawn(erlang, send, [Dest,Msg]);</span><br><span class="line">    Other -&gt;</span><br><span class="line">        Other</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span> erlang:send<span class="params">(Dest, Msg, Options)</span> -&gt; Res when</span><br><span class="line">      Dest :: dst<span class="params">()</span>,</span><br><span class="line">      Msg :: term<span class="params">()</span>,</span><br><span class="line">      Options :: [nosuspend | noconnect],</span><br><span class="line">      Res :: ok | nosuspend | noconnect.</span><br></pre></td></tr></table></figure><p>nosuspend：遇到会挂起进程时不挂起进程，直接返回nosuspend</p><p>noconnect：遇到远程节点没有连接时不自动连接发送消息，直接返回noconnect</p></li><li><p>gen_server:call</p></li><li><p>rpc:call和gen_server:call 区别？</p><p>rpc模块本身就是gen_server进程，随kernel模块启动，rpc进程启动时通过local注册一个rex的名字。</p><p>rpc:call内部调用gen_server:call({Name,Node},Request)，Name是rex，所以说rpc:call是调用远程节点的rex进程做事情，而gen_server:call可以调用任意进程做事情。</p></li><li><p>erlang:now()和os:timestamp()区别？</p><p>erlang:now()获取erlang虚拟机时间，os:timestamp()获取操作系统时间，对于erlang:start_time函数如果调快系统时间，此定时不会提前收到消息。因为erlang:start_time内部使用erlang虚拟机时间。</p></li><li><p>erlang:send_after和erlang:start_time区别？</p><p>主要是TimerRef，超时消息进入邮箱时，start_time函数的消息携带了TimeRef标识。</p></li><li><p>ref数据类型</p><p>Erlang 虚拟机会创建一个新的 ref。由于全局当前 ref 值是用多个变量表示的，所以 make_ref() 会通过一个自旋锁保护对这些变量的操作，递增全局 ref 的值，然后根据新的 ref 值创建新的 ref 对象并返回对应的 Eterm。递增操作针对 word 0 递增，如果 word 0 超过了218218，则进位到 word 1，word 1 归零的话则进位到 word 2。</p><p>我们打印 ref 的时候，得到的是类似 #Ref&lt;0.0.0.2055&gt; 这样的输出，通过 3 个句点将输出结果分为 4 段。第 1 段，和 pid 和 port 的第一段是一样的，表示节点，在本地节点总是为 0，后面 3 段分别为上面的 word 2、1 和 0。所以 ref 较少的时候前面几段都为 0。</p></li><li><p>ets表</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span> new<span class="params">(Name, Options)</span> -&gt; tid<span class="params">()</span> | atom<span class="params">()</span> when</span><br><span class="line">      Name :: atom<span class="params">()</span>,</span><br><span class="line">      Options :: [Option],</span><br><span class="line">      Option :: Type | Access | named_table | &#123;keypos,Pos&#125;</span><br><span class="line">              | &#123;heir, Pid :: pid<span class="params">()</span>, HeirData&#125; | &#123;heir, none&#125; | Tweaks,</span><br><span class="line">      Type :: type<span class="params">()</span>,</span><br><span class="line">      Access :: access<span class="params">()</span>,</span><br><span class="line">      Tweaks :: &#123;write_concurrency, boolean<span class="params">()</span>&#125;</span><br><span class="line">              | &#123;read_concurrency, boolean<span class="params">()</span>&#125;</span><br><span class="line">              | compressed,</span><br><span class="line">      Pos :: pos_integer<span class="params">()</span>,</span><br><span class="line">      HeirData :: term<span class="params">()</span>.</span><br></pre></td></tr></table></figure><p>write_concurrency、read_concurrency是用来提升读写性能的，代价是额外的内存。并不是支持读和写的并发控制的，因为ets本身的读写操作就是原子的。通常来说，<strong>ets写数据时整张表是锁定的</strong>，其他进程不能进行读写直到前面的操作完成。并发写可以改变这个情况，<strong>同一个表中的不同记录可以被多个进程并发读写</strong>。有了这个参数，使得ets写记录时表读写锁变成了读锁，就是说，只要不是同一条记录，还可以继续往这个ets表写入数据，提高了并发写效率。但并发写也有弊端，降低数据连续写入的效率和性能。如果有且只有一个进程在读写数据，将会带来一定的开销。而测试发现这个开销比较小，可以忽略。而且，只有一个进程在读写数据的场合比较小。</p></li><li><p>Pid &lt;A,B,C&gt;</p><p>A对应节点信息（0代表本地节点，其他数字代表远程节点）</p><p>B低15字节代表进程表索引</p><p>C16～18字节代表进程唯一标识</p></li><li><p>erlang:dbg、trace、火焰图</p></li><li><p>receive的理解</p><p>receive会检查遍历进程的邮箱一次，如果匹配到条件，就执行条件后的代码，并去掉邮箱中对应消息，停止匹配过程。等待下一条消息到达时触发再次匹配逻辑。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;gen_server:cast和erlang:send()都可以向指定进程发送消息，两者有什么区别？&lt;/p&gt;
&lt;p&gt;gen_server:cast 内部调用erlang:send使用noconnect&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang" scheme="http://yoursite.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>tcp参数调优</title>
    <link href="http://yoursite.com/2019/01/08/tcp%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2019/01/08/tcp参数调优/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>/etc/sysctl.conf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.ipv4.tcp_fin_timeout = 10</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_window_scaling = 0</span><br><span class="line">net.ipv4.tcp_sack = 0</span><br><span class="line">net.core.netdev_max_backlog = 30000</span><br><span class="line">net.ipv4.tcp_no_metrics_save=1</span><br><span class="line">net.core.somaxconn = 262144</span><br><span class="line">net.ipv4.tcp_syncookies = 0</span><br><span class="line">net.ipv4.tcp_max_orphans = 262144</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line"></span><br><span class="line">fs.file-max = 1024000</span><br><span class="line">net.nf_conntrack_max= 1024000</span><br><span class="line">net.ipv4.tcp_mem=786432 2097152 3145728</span><br></pre></td></tr></table></figure><ol start="2"><li><p>ulimit -a 中open files (-n) 1024000 修改</p><p>vi /etc/profile</p><p>ulimit -n 1024000</p><p>生效：source /etc/profile</p><p>cat /proc/sys/fs/file-max</p><p>修改：pending signals (-i) 128296</p><p>vi /etc/profile</p><p>ulimit -i 128296</p><p>生效：source /etc/profile</p></li><li><p>error, emfile 最大用户进程需要在90-nproc.conf</p><p>vi /etc/security/limits.conf</p><p>soft nofile 65535</p><p>hard nofile 65535</p><p>然后，一般来说，修改ulimit的数值，只需要修改/etc/security/limits.conf即可，但是这个参数需要修改/etc/security/limits.d/90-nproc.conf。centos 6.<em>可以修改/etc/security/limits.d/90-nproc.conf，但centos 5.</em>并没有90-nproc.conf这个文件，我这边是通过修改/etc/security/limits.conf。</p></li><li><p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p><p>CLOSE_WAIT 162</p><p>ESTABLISHED 10163</p><p>SYN_RECV 242</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;/etc/sysctl.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-sysctl" scheme="http://yoursite.com/tags/linux-sysctl/"/>
    
  </entry>
  
  <entry>
    <title>sysctl.conf调整</title>
    <link href="http://yoursite.com/2019/01/08/linux-sysctl%E8%B0%83%E6%95%B4/"/>
    <id>http://yoursite.com/2019/01/08/linux-sysctl调整/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>设置tcp参数一定要小心谨慎,轻易不要更改线上环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">et.ipv4.tcp_tw_reuse    = 1 </span><br><span class="line">net.ipv4.tcp_tw_recycle  = 1 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800 </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096 </span><br><span class="line">net.ipv4.tcp_syncookies = 1 www.2cto.com</span><br></pre></td></tr></table></figure><p>执行 /sbin/sysctl -p 让参数生效。</p><a id="more"></a><ol><li><p>大量TIME_WAIT问题</p><p>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.</p><p>解决方案：</p><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p><p>net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间。</p></li><li><p>参数说明</p><p>tcp_syn_retries ：INTEGER</p><p>默认值是5</p><p>对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1 决定的)</p><p>tcp_synack_retries ：INTEGER</p><p>默认值是5</p><p>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的tcp_syn_retries来决定这个值)</p><p>tcp_keepalive_time ：INTEGER</p><p>默认值是7200(2小时)</p><p>当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击?tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)</p><p>tcp_keepalive_probes：INTEGER</p><p>默认值是9</p><p>TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)</p><p>tcp_keepalive_intvl：INTEGER</p><p>默认值为75</p><p>探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</p><p>tcp_retries1 ：INTEGER</p><p>默认值是3</p><p>放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)</p><p>tcp_retries2 ：INTEGER</p><p>默认值为15</p><p>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</p><p>tcp_orphan_retries ：INTEGER</p><p>默认值是7</p><p>在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</p><p>tcp_fin_timeout ：INTEGER</p><p>默认值是 60</p><p>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。 过去在2.2版本的内核中是 180 秒。您可以设置该值﹐但需要注意﹐如果您的机器为负载很重的web服务器﹐您可能要冒内存被大量无效数据报填满的风险﹐FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ﹐因为它们最多只吃 1.5K 的内存﹐但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30)</p><p>tcp_max_tw_buckets ：INTEGER</p><p>默认值是180000</p><p>系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要人为的降低这个限制﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</p><p>tcp_tw_recycle ：BOOLEAN</p><p>默认值是0</p><p>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</p><p>tcp_tw_reuse：BOOLEAN</p><p>默认值是0</p><p>该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</p><p>tcp_max_orphans ：INTEGER</p><p>缺省值是8192</p><p>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</p><p>tcp_abort_on_overflow ：BOOLEAN</p><p>缺省值是0</p><p>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</p><p>tcp_syncookies ：BOOLEAN</p><p>默认值是0</p><p>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</p><p>注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考:</p><p>tcp_max_syn_backlog</p><p>tcp_synack_retries</p><p>tcp_abort_on_overflow</p><p>syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.)</p><p>tcp_stdurg ：BOOLEAN</p><p>默认值为0</p><p>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在Linux打开它﹐或会导致不能和它们正确沟通。</p><p>tcp_max_syn_backlog ：INTEGER</p><p>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于1024﹐最好修改 include/net/tcp.h 里面的 TCP_SYNQ_HSIZE ﹐以保持TCP_SYNQ_HSIZE*16&lt;=tcp_max_syn_backlog ﹐并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有 效的缓解小规模的SYN Flood攻击(事实证明&lt;1000p/s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.)</p><p>tcp_window_scaling ：INTEGER</p><p>缺省值为1</p><p>该文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）</p><p>tcp_timestamps ：BOOLEAN</p><p>缺省值为1</p><p>Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</p><p>tcp_sack ：BOOLEAN</p><p>缺省值为1</p><p>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</p><p>tcp_fack ：BOOLEAN</p><p>缺省值为1</p><p>打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)</p><p>tcp_dsack ：BOOLEAN</p><p>缺省值为1</p><p>允许TCP发送”两个完全相同”的SACK。</p><p>tcp_ecn ：BOOLEAN</p><p>缺省值为0</p><p>打开TCP的直接拥塞通告功能。</p><p>tcp_reordering ：INTEGER</p><p>默认值是3</p><p>TCP流中重排序的数据报最大数量 。 (一般有看到推荐把这个数值略微调整大一些,比如5)</p><p>tcp_retrans_collapse ：BOOLEAN</p><p>缺省值为1</p><p>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)</p><p>tcp_wmem(3个INTEGER变量)： min, default, max</p><p>min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。</p><p>default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。</p><p>max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）</p><p>tcp_rmem (3个INTEGER变量)： min, default, max</p><p>min：为TCP socket预留用于接收缓冲的内存数量，即使在内存出现紧张情况下tcp socket都至少会有这么多数量的内存用于接收缓冲，默认值为8K。</p><p>default：为TCP socket预留用于接收缓冲的内存数量，默认情况下该值影响其它协议使用的net.core.wmem_default 值。该值决定了在tcp_adv_win_scale、tcp_app_win和tcp_app_win=0默认值情况下，TCP窗口大小为65535。默认值为87380</p><p>max：用于TCP socket接收缓冲的内存最大值。该值不会影响 net.core.wmem_max，”静态”选择参数 SO_SNDBUF则不受该值影响。默认值为 128K。默认值为87380*2 bytes。（可以看出，.max的设置最好是default的两倍,对于NAT来说主要该增加它,我的网络里为 51200 131072 204800）</p><p>tcp_mem(3个INTEGER变量)：low, pressure, high</p><p>low：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 / 4096)。 )</p><p>pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 * 300 / 4096)。 )</p><p>high：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000)</p><p>一般情况下这些值是在系统启动时根据系统内存数量计算得到的。</p><p>tcp_app_win : INTEGER</p><p>默认值是31</p><p>保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。</p><p>tcp_adv_win_scale : INTEGER</p><p>默认值为2</p><p>计算缓冲开销bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale &lt;= 0）。</p><p>tcp_rfc1337 :BOOLEAN</p><p>缺省值为0</p><p>这个开关可以启动对于在RFC1337中描述的”tcp 的time-wait暗杀危机”问题的修复。启用后，内核将丢弃那些发往time-wait状态TCP套接字的RST 包.</p><p>tcp_low_latency : BOOLEAN</p><p>缺省值为0</p><p>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建Beowulf 集群的时候,打开它很有帮助)</p><p>tcp_westwood :BOOLEAN</p><p>缺省值为0</p><p>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项。</p><p>tcp_bic :BOOLEAN</p><p>缺省值为0</p><p>为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设置tcp参数一定要小心谨慎,轻易不要更改线上环境。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;et.ipv4.tcp_tw_reuse    = 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_tw_recycle  = 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_fin_timeout = 30 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_keepalive_time = 1800 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_max_syn_backlog = 4096 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_syncookies = 1 www.2cto.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行 /sbin/sysctl -p 让参数生效。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-sysctl" scheme="http://yoursite.com/tags/linux-sysctl/"/>
    
  </entry>
  
  <entry>
    <title>vimdiff</title>
    <link href="http://yoursite.com/2019/01/08/vimdiff/"/>
    <id>http://yoursite.com/2019/01/08/vimdiff/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>##实用的vim下比较两个文件命令：</p><h3 id="1、-vimdiff-file1-file2"><a href="#1、-vimdiff-file1-file2" class="headerlink" title="1、 vimdiff file1 file2"></a>1、 vimdiff file1 file2</h3><p>终端下输入该命令进入vim，垂直分隔窗口进行比较</p><h3 id="2、-vimdiff-o-file1-file2"><a href="#2、-vimdiff-o-file1-file2" class="headerlink" title="2、 vimdiff -o file1 file2"></a>2、 vimdiff -o file1 file2</h3><p>水平分隔窗口进行比较</p><h3 id="3、-ctrl-w-j-k-h-l"><a href="#3、-ctrl-w-j-k-h-l" class="headerlink" title="3、 ctrl+w (j,k,h,l)"></a>3、 ctrl+w (j,k,h,l)</h3><p>上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l）</p><h3 id="4、-ctrl-w-J-K-H-L"><a href="#4、-ctrl-w-J-K-H-L" class="headerlink" title="4、 ctrl+w (J,K,H,L)"></a>4、 ctrl+w (J,K,H,L)</h3><p>上下左右移动光标所在窗口的位置</p><a id="more"></a><h3 id="5、-zo-和-zc"><a href="#5、-zo-和-zc" class="headerlink" title="5、 zo 和 zc"></a>5、 zo 和 zc</h3><p>打开折叠区 和 关闭折叠区</p><h3 id="6、-c-和-c"><a href="#6、-c-和-c" class="headerlink" title="6、 ]c 和 [c"></a>6、 ]c 和 [c</h3><p>将光标移动到下一个不同区 和 上一个不同区</p><h3 id="7、-do-和-dp"><a href="#7、-do-和-dp" class="headerlink" title="7、 do 和 dp"></a>7、 do 和 dp</h3><p>将光标所在不同区域同步为另一个文件该位置的内容 和 将光标所在不同区域内容同步到另一个文件该位置</p><h3 id="8、-diffu"><a href="#8、-diffu" class="headerlink" title="8、 :diffu[!]"></a>8、 :diffu[!]</h3><p>vim下更新当前比较窗口，比较状态下修改文件后，可调用该命令[中括号不为命令部分，如果加!表示如果外部修改了文件，则重新加载比较]</p><h3 id="9、-diffo"><a href="#9、-diffo" class="headerlink" title="9、 :diffo[!]"></a>9、 :diffo[!]</h3><p>vim下关闭当前窗口比较状态，如果加!则关闭所有窗口的比较状态</p><h3 id="10、-diffs-file1"><a href="#10、-diffs-file1" class="headerlink" title="10、:diffs file1"></a>10、:diffs file1</h3><p>vim下加入file1和当前光标所在窗口进行比较，水平分隔窗口</p><h3 id="11、-vert-diffs-file1"><a href="#11、-vert-diffs-file1" class="headerlink" title="11、:vert diffs file1"></a>11、:vert diffs file1</h3><p>vim下加入file1和当前光标所在窗口进行比较，垂直分隔窗口</p><h3 id="12、-difft"><a href="#12、-difft" class="headerlink" title="12、:difft"></a>12、:difft</h3><p>vim下将光标所在窗口变为比较窗口</p><p>##其它技巧：</p><h3 id="1、-diff-u-file1-file2-gt-file3"><a href="#1、-diff-u-file1-file2-gt-file3" class="headerlink" title="1、 diff -u file1 file2 &gt; file3"></a>1、 diff -u file1 file2 &gt; file3</h3><p>终端下输入该命令，可以将file1和file2的比较结果输出到file3中，-u 表示以合并格式比较，-c 为上下文格式，不加为一般格式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##实用的vim下比较两个文件命令：&lt;/p&gt;
&lt;h3 id=&quot;1、-vimdiff-file1-file2&quot;&gt;&lt;a href=&quot;#1、-vimdiff-file1-file2&quot; class=&quot;headerlink&quot; title=&quot;1、 vimdiff file1 file2&quot;&gt;&lt;/a&gt;1、 vimdiff file1 file2&lt;/h3&gt;&lt;p&gt;终端下输入该命令进入vim，垂直分隔窗口进行比较&lt;/p&gt;
&lt;h3 id=&quot;2、-vimdiff-o-file1-file2&quot;&gt;&lt;a href=&quot;#2、-vimdiff-o-file1-file2&quot; class=&quot;headerlink&quot; title=&quot;2、 vimdiff -o file1 file2&quot;&gt;&lt;/a&gt;2、 vimdiff -o file1 file2&lt;/h3&gt;&lt;p&gt;水平分隔窗口进行比较&lt;/p&gt;
&lt;h3 id=&quot;3、-ctrl-w-j-k-h-l&quot;&gt;&lt;a href=&quot;#3、-ctrl-w-j-k-h-l&quot; class=&quot;headerlink&quot; title=&quot;3、 ctrl+w (j,k,h,l)&quot;&gt;&lt;/a&gt;3、 ctrl+w (j,k,h,l)&lt;/h3&gt;&lt;p&gt;上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l）&lt;/p&gt;
&lt;h3 id=&quot;4、-ctrl-w-J-K-H-L&quot;&gt;&lt;a href=&quot;#4、-ctrl-w-J-K-H-L&quot; class=&quot;headerlink&quot; title=&quot;4、 ctrl+w (J,K,H,L)&quot;&gt;&lt;/a&gt;4、 ctrl+w (J,K,H,L)&lt;/h3&gt;&lt;p&gt;上下左右移动光标所在窗口的位置&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-vimdiff" scheme="http://yoursite.com/tags/linux-vimdiff/"/>
    
  </entry>
  
  <entry>
    <title>linux查看系统命令</title>
    <link href="http://yoursite.com/2019/01/08/linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2019/01/08/linux系统信息查看/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>inux 查看系统信息命令是linux初学者必备的基础知识, 这些命令也非常有用, 因为进入linux第一件事就可能是首先查看系统信息, 因此必要的系统的学习一下这些linux系统信息命令还是非常有必要的!</p><a id="more"></a><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uname -a # 查看内核/操作系统/CPU信息 </span></span><br><span class="line"><span class="comment"># head -n 1 /etc/issue # 查看操作系统版本 </span></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo # 查看CPU信息 </span></span><br><span class="line"><span class="comment"># hostname # 查看计算机名 </span></span><br><span class="line"><span class="comment"># lspci -tv # 列出所有PCI设备 </span></span><br><span class="line"><span class="comment"># lsusb -tv # 列出所有USB设备 </span></span><br><span class="line"><span class="comment"># lsmod # 列出加载的内核模块 </span></span><br><span class="line"><span class="comment"># env # 查看环境变量资源 </span></span><br><span class="line"><span class="comment"># free -m # 查看内存使用量和交换区使用量 </span></span><br><span class="line"><span class="comment"># df -h # 查看各分区使用情况 </span></span><br><span class="line"><span class="comment"># du -sh &lt;目录名&gt; # 查看指定目录的大小 </span></span><br><span class="line"><span class="comment"># grep MemTotal /proc/meminfo # 查看内存总量 </span></span><br><span class="line"><span class="comment"># grep MemFree /proc/meminfo # 查看空闲内存量 </span></span><br><span class="line"><span class="comment"># uptime # 查看系统运行时间、用户数、负载 </span></span><br><span class="line"><span class="comment"># cat /proc/loadavg # 查看系统负载磁盘和分区 </span></span><br><span class="line"><span class="comment"># mount | column -t # 查看挂接的分区状态 </span></span><br><span class="line"><span class="comment"># fdisk -l # 查看所有分区 </span></span><br><span class="line"><span class="comment"># swapon -s # 查看所有交换分区 </span></span><br><span class="line"><span class="comment"># hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) </span></span><br><span class="line"><span class="comment"># dmesg | grep IDE # 查看启动时IDE设备检测状况网络 </span></span><br><span class="line"><span class="comment"># ifconfig # 查看所有网络接口的属性 </span></span><br><span class="line"><span class="comment"># iptables -L # 查看防火墙设置 </span></span><br><span class="line"><span class="comment"># route -n # 查看路由表 </span></span><br><span class="line"><span class="comment"># netstat -lntp # 查看所有监听端口 </span></span><br><span class="line"><span class="comment"># netstat -antp # 查看所有已经建立的连接 </span></span><br><span class="line"><span class="comment"># netstat -s # 查看网络统计信息进程 </span></span><br><span class="line"><span class="comment"># ps -ef # 查看所有进程 </span></span><br><span class="line"><span class="comment"># top # 实时显示进程状态用户 </span></span><br><span class="line"><span class="comment"># w # 查看活动用户 </span></span><br><span class="line"><span class="comment"># id &lt;用户名&gt; # 查看指定用户信息 </span></span><br><span class="line"><span class="comment"># last # 查看用户登录日志 </span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/passwd # 查看系统所有用户 </span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/group # 查看系统所有组 </span></span><br><span class="line"><span class="comment"># crontab -l # 查看当前用户的计划任务服务 </span></span><br><span class="line"><span class="comment"># chkconfig –list # 列出所有系统服务 </span></span><br><span class="line"><span class="comment"># chkconfig –list | grep on # 列出所有启动的系统服务程序 </span></span><br><span class="line"><span class="comment"># rpm -qa # 查看所有安装的软件包</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inux 查看系统信息命令是linux初学者必备的基础知识, 这些命令也非常有用, 因为进入linux第一件事就可能是首先查看系统信息, 因此必要的系统的学习一下这些linux系统信息命令还是非常有必要的!&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac iTerm使用</title>
    <link href="http://yoursite.com/2018/12/20/iTerm%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/20/iTerm命令/</id>
    <published>2018-12-20T09:23:57.000Z</published>
    <updated>2018-12-20T09:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac iTerm终端使用</p><a id="more"></a><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>新建标签：command + t关闭标签：command + w切换标签：command + 数字 command + 左右方向键切换全屏：command + enter查找：command + f</code></pre><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><pre><code>垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键 command + [ 或 command + ]查看历史命令：command + ;查看剪贴板历史：command + shift + h</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>清除当前行：ctrl + u到行首：ctrl + a到行尾：ctrl + e前进后退：ctrl + f/b (相当于左右方向键)上一条命令：ctrl + p搜索命令历史：ctrl + r删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w删除到文本末尾：ctrl + k交换光标处文本：ctrl + t清屏1：command + r清屏2：ctrl + l</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac iTerm终端使用&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac iTerm" scheme="http://yoursite.com/tags/Mac-iTerm/"/>
    
  </entry>
  
  <entry>
    <title>account</title>
    <link href="http://yoursite.com/2018/12/16/account/"/>
    <id>http://yoursite.com/2018/12/16/account/</id>
    <published>2018-12-16T10:35:26.000Z</published>
    <updated>2018-12-16T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码账号"><a href="#代码账号" class="headerlink" title="代码账号"></a>代码账号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:good-leaf</span><br><span class="line">mail:rwzgnyyj</span><br></pre></td></tr></table></figure><h3 id="软件账号"><a href="#软件账号" class="headerlink" title="软件账号"></a>软件账号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:yangyajun-soft</span><br><span class="line">mail:yangyajun_c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码账号&quot;&gt;&lt;a href=&quot;#代码账号&quot; class=&quot;headerlink&quot; title=&quot;代码账号&quot;&gt;&lt;/a&gt;代码账号&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="self" scheme="http://yoursite.com/categories/self/"/>
    
    
      <category term="self" scheme="http://yoursite.com/tags/self/"/>
    
  </entry>
  
  <entry>
    <title>erlang 防坑指南</title>
    <link href="http://yoursite.com/2018/12/16/erlang%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/12/16/erlang防坑指南/</id>
    <published>2018-12-16T10:35:26.000Z</published>
    <updated>2018-12-16T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言在使用中都会遇到这样那样的问题，erlang也是。这里整理下我遇到的一些问题，避免继续踩坑。说实话，“防坑指南”这个标题有点过于标新立异，不过还是希望能引起重视，避免在实际开发中重复犯这些问题。<br><a id="more"></a></p><hr><p>title: erlang防坑指南<br>date: 2019-01-08 14:22:53<br>updated: 2019-01-08 14:22:53<br>categories: develop-language</p><h2 id="tags-erlang"><a href="#tags-erlang" class="headerlink" title="tags: erlang"></a>tags: erlang</h2><h3 id="‘–’-运算与-‘-’运算"><a href="#‘–’-运算与-‘-’运算" class="headerlink" title="‘–’ 运算与 ‘++’运算"></a>‘–’ 运算与 ‘++’运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt; [1,2,3,4] -- [1] -- [2]. </span><br><span class="line">[2,3,4]</span><br><span class="line">算是erlang经典的问题了。这是从后面算起的，先算 [1] -- [2] ，得到 [1] 后被 [1,2,3,4] --，最后得到 [2,3,4]</span><br><span class="line"> &apos;++&apos;运算也是一样的，也是从后面开始算起。</span><br><span class="line">2&gt; [1,2,3,4] -- [1] ++ [2,3,4].</span><br><span class="line">[]</span><br><span class="line">另外，以下这种情况也要注意，只会减去遇到的第一个元素。</span><br><span class="line">3&gt; [1,2,3,2] -- [2].</span><br><span class="line">[1,3,2]</span><br></pre></td></tr></table></figure><h3 id="erlang-function-exported"><a href="#erlang-function-exported" class="headerlink" title="erlang:function_exported()"></a>erlang:function_exported()</h3><p>这个接口是用来检查模块函数是否导出，但是，如果模块没加载过，这个函数返回值就是false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3&gt; erlang:function_exported(odbc,start,0).</span><br><span class="line">false</span><br><span class="line">4&gt; odbc:start().</span><br><span class="line">ok</span><br><span class="line">5&gt; erlang:function_exported(odbc,start,0).</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="erlang-list-to-binary"><a href="#erlang-list-to-binary" class="headerlink" title="erlang:list_to_binary()"></a>erlang:list_to_binary()</h3><p>如果参数是多层嵌套结构，就会被扁平化掉，使用 binary_to_list 不能转成原来的数据，也就是不可逆的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6&gt; list_to_binary([1,2,[3,4],5]) .</span><br><span class="line">&lt;&lt;1,2,3,4,5&gt;&gt;</span><br><span class="line">如果想可逆，可以使用 erlang:term_to_binary</span><br><span class="line">7&gt; binary_to_term(term_to_binary([1,2,[3,4],5])).</span><br><span class="line">[1,2,[3,4],5]</span><br></pre></td></tr></table></figure><h3 id="random-uniform"><a href="#random-uniform" class="headerlink" title="random:uniform()"></a>random:uniform()</h3><p>这个用于生成随机数，返回一个随机数浮点数。但是，这个函数的随机初始种子是个定值，而且种子就放在进程字典，就是说每个进程生成的随机数都是一样的。坑爹啊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end)</span><br><span class="line">,ok.</span><br><span class="line">0.4435846174457203 0.7230402056221108</span><br><span class="line">ok</span><br><span class="line">11&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end)</span><br><span class="line">,ok.</span><br><span class="line">0.4435846174457203 0.7230402056221108</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>所以，解决的方法就是进程启动后要重置随机数种子，然后再使用这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13&gt; random:seed(erlang:now()), random:uniform().</span><br><span class="line">0.4691405130019146</span><br></pre></td></tr></table></figure><h3 id="io-lib-char-list"><a href="#io-lib-char-list" class="headerlink" title="io_lib:char_list()"></a>io_lib:char_list()</h3><p>这个函数在R15和R16下运行结果可能是相反的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R15下：</span><br><span class="line">Eshell V5.9.3.1 (abort with ^G)</span><br><span class="line">1&gt; io_lib:char_list([10100,10600,20100]).</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">R16下：</span><br><span class="line">Eshell V5.10.1 (abort with ^G) </span><br><span class="line">1&gt; io_lib:char_list([10100,10600,20100]). </span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="不同类型数据比较"><a href="#不同类型数据比较" class="headerlink" title="不同类型数据比较"></a>不同类型数据比较</h3><p>比较公式为：number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</p><h3 id="系统限制"><a href="#系统限制" class="headerlink" title="系统限制"></a>系统限制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mnesia或dets有2G限制（无法定制）</span><br><span class="line">2. ets表最大数量默认1400（可用 ERL_MAX_ETS_TABLES 定制）</span><br><span class="line">3. 原子最大数量默认 1048576 （可用 +t 定制）</span><br><span class="line">4. 进程最大数量默认 32768   （可用  +P 定制， 范围1024-134217727）</span><br><span class="line">5. 端口/文件句柄最大数量默认 16384  （可用  +Q  定制， 范围1024-134217727）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何语言在使用中都会遇到这样那样的问题，erlang也是。这里整理下我遇到的一些问题，避免继续踩坑。说实话，“防坑指南”这个标题有点过于标新立异，不过还是希望能引起重视，避免在实际开发中重复犯这些问题。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang" scheme="http://yoursite.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq安装</title>
    <link href="http://yoursite.com/2018/12/14/rabbitmq%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/12/14/rabbitmq安装/</id>
    <published>2018-12-14T09:23:57.000Z</published>
    <updated>2018-12-14T09:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>版本：rabbitmq-server-3.6.6-1.el6.noarch.rpm</p><a id="more"></a><h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="built_in">cd</span> /tmp &amp;&amp; wget https://yangyajun-soft.github.io/rabbitmq3.6.6/rabbitmq-server-3.6.6-1.el6.noarch.rpm</span><br><span class="line">yum install -y rabbitmq-server-3.6.6-1.el6.noarch.rpm</span><br><span class="line">chown rabbitmq:rabbitmq /etc/rabbitmq</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># set cookie</span></span><br><span class="line">sudo su rabbitmq</span><br><span class="line"><span class="built_in">echo</span> cookie &gt; /var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">chmod u=r,g=,o= /var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">wget https://yangyajun-soft.github.io//rabbitmq3.6.6/rabbitmq.config -O /etc/rabbitmq/rabbitmq.config</span><br><span class="line"><span class="comment"># start</span></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"><span class="comment"># join cluster</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit@host</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="comment"># config</span></span><br><span class="line">rabbitmqctl set_policy ha-backup <span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"exactly", "ha-params":2, "ha-sync-mode":"automatic"&#125;'</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment"># add admin</span></span><br><span class="line">rabbitmqctl add_user admin password</span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> admin <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="comment"># add user</span></span><br><span class="line">rabbitmqctl add_user user password</span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">"/"</span> user <span class="string">'.*'</span> <span class="string">'.*'</span> <span class="string">'.*'</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>enabled_plugins</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rabbitmq_management,rabbitmq_tracing].</span><br></pre></td></tr></table></figure></li><li><p>rabbitmq.config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;rabbit, [&#123;disk_free_limit, 5242880&#125;</span><br><span class="line">          ,&#123;vm_memory_high_watermark, 0.8&#125;</span><br><span class="line">          ,&#123;loopback_users, []&#125;</span><br><span class="line">         ]&#125;,</span><br><span class="line">&#123;rabbitmq_management, [&#123;listener, [&#123;port, 8080&#125;]&#125;]&#125;</span><br><span class="line">&#123;rabbitmq_management_agent, [ &#123;force_fine_statistics, <span class="literal">false</span>&#125; ] &#125;</span><br><span class="line">].</span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;版本：rabbitmq-server-3.6.6-1.el6.noarch.rpm&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="rabbitmq安装" scheme="http://yoursite.com/tags/rabbitmq%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>redis安装</title>
    <link href="http://yoursite.com/2018/12/14/redis%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/12/14/redis安装/</id>
    <published>2018-12-14T09:23:57.000Z</published>
    <updated>2018-12-14T09:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>版本：redis-3.2.8-1.el6.remi.x86_64.rpm</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /tmp &amp;&amp; wget https:<span class="comment">//yangyajun-soft.github.io/redis/redis-3.2.8-1.el6.remi.x86_64.rpm</span></span><br><span class="line">yum install -y redis<span class="number">-3.2</span><span class="number">.8</span><span class="number">-1.</span>el6.remi.x86_64.rpm</span><br><span class="line">su sankuai</span><br><span class="line">mkdir -p /opt/xxx/apps/redis</span><br><span class="line">cd /opt/xxx/apps/redis</span><br><span class="line">## <span class="number">6379</span></span><br><span class="line">mkdir -p /opt/xxx/appdatas/redis6379</span><br><span class="line">wget https:<span class="comment">//yangyajun-soft.github.io/redis/redis_6379_3.conf -O 6379.conf</span></span><br><span class="line">redis-server /opt/xxx/apps/redis/<span class="number">6379.</span>conf</span><br><span class="line">## <span class="number">6380</span></span><br><span class="line">mkdir -p /opt/xxx/appdatas/redis6380</span><br><span class="line">wget https:<span class="comment">//yangyajun-soft.github.io/redis/redis_6380_3.conf -O 6380.conf</span></span><br><span class="line">## <span class="number">6381</span></span><br><span class="line">mkdir -p /opt/xxx/appdatas/redis6381</span><br><span class="line">wget https:<span class="comment">//yangyajun-soft.github.io/redis/redis_6381_3.conf -O 6381.conf</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;版本：redis-3.2.8-1.el6.remi.x86_64.rpm&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>hexo 安装</title>
    <link href="http://yoursite.com/2018/12/14/hexo%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/12/14/hexo安装/</id>
    <published>2018-12-14T09:23:57.000Z</published>
    <updated>2018-12-14T09:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git设置"><a href="#git设置" class="headerlink" title="git设置"></a>git设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"good-leaf"</span></span><br><span class="line">git config --global user.email <span class="string">"rwzgnyyj@xxx.com"</span></span><br></pre></td></tr></table></figure><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">cd</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>添加git地址：使用ssh时，需要将本机ssh key添加到github上，并且选择ssh访问方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git<span class="meta">@github</span>.com:good-leaf/good-leaf.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>修改端口：vi _config.yml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">4001</span></span><br><span class="line">  compress: <span class="keyword">true</span></span><br><span class="line">  header: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>搜索支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure><h2 id="更换主题：访问页面显示"><a href="#更换主题：访问页面显示" class="headerlink" title="更换主题：访问页面显示"></a>更换主题：访问页面显示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extends partial/layout</span><br><span class="line"></span><br><span class="line">block container</span><br><span class="line">    include mixins/post</span><br><span class="line">    +posts()</span><br><span class="line"></span><br><span class="line">block pagination</span><br><span class="line">    include mixins/paginator</span><br><span class="line">    +home()</span><br><span class="line"></span><br><span class="line">block copyright</span><br><span class="line">    include partial/copyright</span><br></pre></td></tr></table></figure><p>解决：npm install –save hexo-renderer-jade</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git设置&quot;&gt;&lt;a href=&quot;#git设置&quot; class=&quot;headerlink&quot; title=&quot;git设置&quot;&gt;&lt;/a&gt;git设置&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
