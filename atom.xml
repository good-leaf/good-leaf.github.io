<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>会飞的鱼</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-01T12:40:42.510Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/01/RPC/"/>
    <id>http://yoursite.com/2019/03/01/RPC/</id>
    <published>2019-03-01T12:40:42.513Z</published>
    <updated>2019-03-01T12:40:42.510Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: RPC<br>date: 2019-02-23 14:22:53<br>updated: 2019-02-23 14:22:53<br>categories: 协议</p><h2 id="tags-RPC调用"><a href="#tags-RPC调用" class="headerlink" title="tags: RPC调用"></a>tags: RPC调用</h2><p>RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议）他们最本质的区别，就是RPC主要工作在TCP协议之上，而HTTP服务主要是工作在HTTP协议之上，我们都知道HTTP协议是在传输层协议TCP之上的，所以效率来看的话，RPC当然是要更胜一筹。</p><a id="more"></a><p>1、RPC服务<br>（1）RPC架构<br>      先说说RPC服务的基本架构吧。一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件：<br>    1)客户端（Client），服务的调用方。<br>    2)服务端（Server），真正的服务提供者。<br>    3)客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。<br>    4)服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</p><p><img src="https://img-blog.csdn.net/20180409220809083" alt=""></p><p>（2）同步调用与异步调用<br>      什么是同步调用？什么是异步调用？同步调用就是客户端等待调用执行完成并返回结果。异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然啦，callable也是可以的，我们不去获取Future就可以了。<br>（3）流行的RPC框架<br>    目前流行的开源RPC框架还是比较多的。下面重点介绍三种：<br>    1）gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。<br>    2）Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。<br>    3）Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。<br>2、HTTP服务</p><p>（1）HTTP接口<br>      相比RPC，HTTP接口开发也就是我们常说的RESTful风格的服务接口。的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。做后台接口开发的时候，需要写一份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: RPC&lt;br&gt;date: 2019-02-23 14:22:53&lt;br&gt;updated: 2019-02-23 14:22:53&lt;br&gt;categories: 协议&lt;/p&gt;
&lt;h2 id=&quot;tags-RPC调用&quot;&gt;&lt;a href=&quot;#tags-RPC调用&quot; class=&quot;headerlink&quot; title=&quot;tags: RPC调用&quot;&gt;&lt;/a&gt;tags: RPC调用&lt;/h2&gt;&lt;p&gt;RPC（即Remote Procedure Call，远程过程调用）和HTTP（HyperText Transfer Protocol，超文本传输协议）他们最本质的区别，就是RPC主要工作在TCP协议之上，而HTTP服务主要是工作在HTTP协议之上，我们都知道HTTP协议是在传输层协议TCP之上的，所以效率来看的话，RPC当然是要更胜一筹。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ejabberd编码风格</title>
    <link href="http://yoursite.com/2019/03/01/ejabberd%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    <id>http://yoursite.com/2019/03/01/ejabberd编码风格/</id>
    <published>2019-03-01T09:22:53.000Z</published>
    <updated>2019-03-01T09:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ejabberd编码风格"><a href="#ejabberd编码风格" class="headerlink" title="ejabberd编码风格"></a>ejabberd编码风格</h3><p><a href="http://www.erlang.se/doc/programming_rules.shtml" target="_blank" rel="noopener">Erlang编码规则</a></p><p><a href="https://github.com/inaka/erlang_guidelines/blob/master/README.md" target="_blank" rel="noopener">ejabberd编码风格</a></p><ul><li><p>更改别人的代码时，保持现有风格。</p></li><li><p>2个空格缩进</p></li><li><p>参数间放置空格</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(spaces)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">3</span>, good/<span class="number">3</span>])</span>.</span><br><span class="line"><span class="comment">% @doc no spaces</span></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(_My,_Space,_Bar)</span>-&gt;</span>[is,'<span class="keyword">not</span>',working].</span><br><span class="line"><span class="comment">% @doc spaces!!</span></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(_Hey, _Now, _It)</span> -&gt;</span> [<span class="string">"works "</span> ++ <span class="string">"again, "</span> | [hooray]].</span><br></pre></td></tr></table></figure></li><li><p>行尾不留空白</p></li><li><p>每行100列，100字符为最大值</p></li><li><p>case表达式执行小函数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(smaller_functions)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">0</span>, bad/<span class="number">1</span>, good/<span class="number">0</span>, good/<span class="number">1</span>])</span>.</span><br><span class="line"><span class="comment">%% @doc function with just a case</span></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(Arg)</span> -&gt;</span></span><br><span class="line">  <span class="keyword">case</span> Arg <span class="keyword">of</span></span><br><span class="line">    this_one -&gt; should:be(a, function, clause);</span><br><span class="line">    and_this_one -&gt; should:be(another, function, clause)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"><span class="comment">%% @doc usage of pattern matching</span></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(this_one)</span> -&gt;</span> is:a(function, clause);</span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(and_this_one)</span> -&gt;</span> is:another(function, clause).</span><br><span class="line"><span class="comment">%% @doc function with an internal case</span></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  InitialArg = some:initial_arg(),</span><br><span class="line">  InternalResult =</span><br><span class="line">  <span class="keyword">case</span> InitialArg <span class="keyword">of</span></span><br><span class="line">    this_one -&gt; should:be(a, function, clause);</span><br><span class="line">      and_this_one -&gt; should:be(another, function, clause)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  some:modification(InternalResult).</span><br><span class="line"><span class="comment">%% @doc usage of function clauses instead of an internal case</span></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  InitialArg = some:initial_arg(),</span><br><span class="line">  InternalResult = good(InitialArg),</span><br><span class="line">  some:modification(InternalResult).</span><br></pre></td></tr></table></figure></li><li><p>模块功能单一，不要把无关功能放在一个模块中</p></li><li><p>单元测试，一个函数测试一个点，不要把多个测试点写一起</p></li><li><p>按功能为模块分组，设置子目录</p></li><li><p>头文件</p><p>不应包含类型定义、记录定义、函数定义；</p><p>可能包含红定义，但应避免使用宏；</p><p>在头文件中包含记录定义可促进跨模块共享这些记录的内部细节，增加耦合并防止封装，从而使更改和维护代码变得更加困难。记录应该在他们自己的模块中定义，这些模块应该提供不透明的数据类型和访问和操作记录的功能。</p><p>函数定义绝对不应包含在头文件中，因为它会导致代码重复。</p></li><li><p>程序的函数调用图应该努力成为有向无环图</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(spaghetti)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">0</span>, good/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  Client = active_user:get_current_client(),</span><br><span class="line">  [binary_to_list(Org)</span><br><span class="line">   || Org &lt;- autocomplete_db:members(</span><br><span class="line">              <span class="keyword">case</span> Client <span class="keyword">of</span></span><br><span class="line">                home_client -&gt;</span><br><span class="line">                  &lt;&lt;<span class="string">"our:organizations"</span>&gt;&gt;;</span><br><span class="line">                aperture_science -&gt;</span><br><span class="line">                  &lt;&lt;<span class="string">"client:"</span>, (prefix_for(aperture_science))/binary, <span class="string">":orgs"</span>&gt;&gt;;</span><br><span class="line">                wayne_ents -&gt;</span><br><span class="line">                  &lt;&lt;<span class="string">"client:"</span>, (prefix_for(wayne_ents))/binary, <span class="string">":orgs"</span>&gt;&gt;</span><br><span class="line">              <span class="keyword">end</span>)].</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  Client = active_user:get_current_client(),</span><br><span class="line">  RawOrgs = autocomplete_db:members(client_ac_key(Client)),</span><br><span class="line">  [binary_to_list(Org) || Org &lt;- RawOrgs].</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">client_ac_key</span><span class="params">(home_client)</span> -&gt;</span> &lt;&lt;<span class="string">"our:organizations"</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="title">client_ac_key</span><span class="params">(Client)</span> -&gt;</span></span><br><span class="line">  Prefix = prefix_for(Client),</span><br><span class="line">  &lt;&lt;<span class="string">"client:"</span>, Prefix/binary, <span class="string">":orgs"</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">prefix_for</span><span class="params">(aperture_science)</span> -&gt;</span> &lt;&lt;<span class="string">"as"</span>&gt;&gt;;</span><br><span class="line"><span class="function"><span class="title">prefix_for</span><span class="params">(wayne_ents)</span> -&gt;</span> &lt;&lt;<span class="string">"we"</span>&gt;&gt;.</span><br></pre></td></tr></table></figure></li><li><p>避免动态调用</p><p>动态调用语法，不能使用xref对代码进行检查。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(dyn_calls)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>, good/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(Arg)</span> -&gt;</span></span><br><span class="line">  Mods = [module_1, module_2, module_3],</span><br><span class="line">  Fun = my_function,</span><br><span class="line">  lists:foreach(</span><br><span class="line">    <span class="keyword">fun</span>(Mod) -&gt;</span><br><span class="line">      Mod:Fun(Arg)</span><br><span class="line">    <span class="keyword">end</span>, Mods).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(Arg)</span> -&gt;</span></span><br><span class="line">  mdoule_1:my_function(Arg),</span><br><span class="line">  module_2:my_function(Arg),</span><br><span class="line">  module_3:my_function(Arg).</span><br></pre></td></tr></table></figure></li><li><p>避免深层嵌套</p><p>嵌套级别表示函数中的逻辑深度。</p></li><li><p>避免if表达式</p><p>if在代码中引入了静态布尔逻辑，从而降低了代码的灵活性。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">-module</span><span class="params">(no_if)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>, better/<span class="number">1</span>, good/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(Connection)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;Transport, Version&#125; = other_place:get_http_params(),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">    Transport =/= cowboy_spdy, Version =:= 'HTTP/1.1' -&gt;</span><br><span class="line">      [&#123;&lt;&lt;<span class="string">"connection"</span>&gt;&gt;, utils:atom_to_connection(Connection)&#125;];</span><br><span class="line">    <span class="literal">true</span> -&gt;</span><br><span class="line">      []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">better</span><span class="params">(Connection)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;Transport, Version&#125; = other_place:get_http_params(),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> &#123;Transport, Version&#125; <span class="keyword">of</span></span><br><span class="line"></span><br><span class="line">    &#123;cowboy_spdy, 'HTTP/<span class="number">1.1</span>'&#125; -&gt;</span><br><span class="line">      [&#123;&lt;&lt;<span class="string">"connection"</span>&gt;&gt;, utils:atom_to_connection(Connection)&#125;];</span><br><span class="line">    &#123;_, _&#125; -&gt;</span><br><span class="line">      []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(Connection)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;Transport, Version&#125; = other_place:get_http_params(),</span><br><span class="line"></span><br><span class="line">  connection_headers(Transport, Version, Connection).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">connection_headers</span><span class="params">(cowboy_spdy, 'HTTP/<span class="number">1.1</span>', Connection)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">    [&#123;&lt;&lt;<span class="string">"connection"</span>&gt;&gt;, utils:atom_to_connection(Connection)&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">connection_headers</span><span class="params">(_, _, _)</span> -&gt;</span></span><br><span class="line"></span><br><span class="line">    [].</span><br></pre></td></tr></table></figure></li><li><p>避免嵌套try….catch</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(nested_try_catch)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">0</span>, good1/<span class="number">0</span>, good2/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    maybe:throw(exception1),</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">      maybe:throw(exception2),</span><br><span class="line">      <span class="string">"We are safe!"</span></span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">      _:exception2 -&gt;</span><br><span class="line">        <span class="string">"Oh, no! Exception #2"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    _:exception1 -&gt; <span class="string">"Bummer! Exception #1"</span></span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good1</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    maybe:throw(exception1),</span><br><span class="line">    maybe:throw(exception2),</span><br><span class="line">    <span class="string">"We are safe!"</span></span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    _:exception1 -&gt;</span><br><span class="line">      <span class="string">"Bummer! Exception #1"</span>;</span><br><span class="line">    _:exception2 -&gt;</span><br><span class="line">      <span class="string">"Oh, no! Exception #2"</span></span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good2</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">    maybe:throw(exception1),</span><br><span class="line">    a_function:that_deals(with, exception2),</span><br><span class="line">    <span class="string">"We are safe!"</span></span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    _:exception1 -&gt;</span><br><span class="line">      <span class="string">"Bummer! Exception #1"</span></span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></li><li><p>模块命名要统一</p></li><li><p>函数名称</p><p>  函数名称只能使用小写字符和数字。函数名中单词必须用”_” </p></li><li><p>变量名称 </p><p>CameCase必须用于变量。</p></li><li><p>iolists 尽可能使用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(iolists)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([good/<span class="number">1</span>, bad/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(Param)</span> -&gt;</span> <span class="string">"Hello "</span> ++ binary_to_list(Param) ++ <span class="string">"! Have a nice day!"</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(Param)</span> -&gt;</span> [<span class="string">"Hello "</span>, Param, <span class="string">"! Have a nice day!"</span>].</span><br></pre></td></tr></table></figure></li><li><p>大写宏</p><p>  宏使代码更难调试。</p></li><li><p>尽量不要把宏作为模块或者函数名</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(macro_mod_names)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>. <span class="comment">% Oh, god! Why??</span></span><br><span class="line"><span class="keyword">-define</span><span class="params">(TM, another_module)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">1</span>, good/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">(Arg)</span> -&gt;</span></span><br><span class="line">  Parsed = gen_server:call(?SERVER, &#123;parse, Arg&#125;),</span><br><span class="line">  ?TM:handle(Parsed).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">(Arg)</span> -&gt;</span></span><br><span class="line">  Parsed = gen_server:call(?MODULE, &#123;parse, Arg&#125;),</span><br><span class="line">  another_module:handle(Parsed).</span><br></pre></td></tr></table></figure></li><li><p>记录名称</p><p>记录名称只能使用小写字符，记录名称中的单词必须用”_”分隔。同样的规则适用于记录字段名称。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(record_names)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([records/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(badName, &#123;&#125;)</span>.</span><br><span class="line"><span class="keyword">-record</span><span class="params">(bad_field_name, &#123;badFieldName :: any()&#125;)</span>.</span><br><span class="line"><span class="keyword">-record</span><span class="params">('UPPERCASE', &#123;'THIS_IS_BAD' :: any()&#125;)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(good_name, &#123;good_field_name :: any()&#125;)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">records</span><span class="params">()</span> -&gt;</span> [#badName&#123;&#125;, #bad_field_name&#123;&#125;, #'UPPERCASE'&#123;&#125;, #good_name&#123;&#125;].</span><br></pre></td></tr></table></figure></li><li><p>不要分享记录</p><p>记录不应在多个模块之间共享。如果需要共享表示为记录的<em>对象</em>，请使用opaque导出类型并在模块中提供足够的访问者函数。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(record_sharing)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span><span class="params">(<span class="string">"record_sharing.hrl"</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([bad/<span class="number">0</span>, good/<span class="number">0</span>, good_field/<span class="number">1</span>, good_field/<span class="number">2</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(good, &#123;good_field :: string()&#125;)</span>.</span><br><span class="line">-opaque good<span class="params">()</span> :: #good&#123;&#125;.</span><br><span class="line">-export_type<span class="params">([good/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-spec</span> good<span class="params">()</span> -&gt; good<span class="params">()</span>.</span><br><span class="line"><span class="function"><span class="title">good</span><span class="params">()</span> -&gt;</span> #good&#123;&#125;.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-spec</span> good_field<span class="params">(good())</span> -&gt; string<span class="params">()</span>.</span><br><span class="line"><span class="function"><span class="title">good_field</span><span class="params">(#good&#123;&#125; = Good)</span> -&gt;</span> Good#good.good_field.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-spec</span> good_field<span class="params">(good(), string())</span> -&gt; good<span class="params">()</span>.</span><br><span class="line"><span class="function"><span class="title">good_field</span><span class="params">(#good&#123;&#125; = Good, Value)</span> -&gt;</span> Good#good&#123;good_field = Value&#125;.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-spec</span> bad<span class="params">()</span> -&gt; #bad&#123;&#125;.</span><br><span class="line"><span class="function"><span class="title">bad</span><span class="params">()</span> -&gt;</span> #bad&#123;&#125;.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ejabberd编码风格&quot;&gt;&lt;a href=&quot;#ejabberd编码风格&quot; class=&quot;headerlink&quot; title=&quot;ejabberd编码风格&quot;&gt;&lt;/a&gt;ejabberd编码风格&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.erlang.se/
      
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang" scheme="http://yoursite.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>Freeswitch事件</title>
    <link href="http://yoursite.com/2019/02/23/Freeswitch%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/02/23/Freeswitch事件/</id>
    <published>2019-02-23T06:22:53.000Z</published>
    <updated>2019-02-23T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Freeswitch内核之事件类型</p><p>事件 说明<br>3 Channel events 信道事件。<br>3.1 Channel states 信道状态。<br>3.2 CHANNEL_CALLSTATE 信道呼叫状态事件。<br>3.3 CHANNEL_CREATE 创建事件。<br>3.4 CHANNEL_DESTROY 销毁事件。<br>3.5 CHANNEL_STATE 呼叫状态事件。当一个信道切换通话状态时发送。此事件并不包含任何附加信息。<br>3.6 CHANNEL_ANSWER 呼叫应答事件。<br>3.7 CHANNEL_HANGUP 挂机事件。<br>3.8 CHANNEL_HANGUP_COMPLETE 挂机完成事件。<br>3.9 CHANNEL_EXECUTE PBX正在执行呼叫事件。<br>3.10 CHANNEL_EXECUTE_COMPLETE 执行完成。<br>3.11 CHANNEL_BRIDGE 一个呼叫两个端点之间的桥接事件。<br>3.12 CHANNEL_UNBRIDGE 停用桥接事件。<br>3.13 CHANNEL_PROGRESS 进度事件，外呼时对方提醒。或者入呼时提醒。<br>3.14 CHANNEL_PROGRESS_MEDIA 媒体进度事件，外呼时对方提醒。或者入呼时提醒。<br>3.15 CHANNEL_OUTGOING 创建一个外呼事件。<br>3.16 CHANNEL_PARK 一个呼叫被挂起(停放)在PBX中。<br>3.17 CHANNEL_UNPARK 一个呼叫被取消挂起(停放)在PBX中。<br>3.18 CHANNEL_APPLICATION 信道产生的应用程序就是事件application=event一般用来捕获呼转<br>3.19 CHANNEL_HOLD 信道保持，使用uuid_hold或者接收SDP的readonly<br>3.20 CHANNEL_UNHOLD 触发后uuid_hold关闭<uuid>或者接收到INVITE SDP= SendRecv的<br>3.21 CHANNEL_ORIGINATE 信道发起事件，触发完成发起（或桥）。<br>3.22 CHANNEL_UUID uuid事件表示唯一的ID通道已经改变。原来的ID将被报告的旧唯一ID。此事件会发生，当您使用参数origination_uuid时发出命令发起/桥。<br>4 System events<br>4.1 SHUTDOWN 设置以启动的FreeSWITCH的关机顺序。<br>4.2 MODULE_LOAD 模块加载<br>4.3 MODULE_UNLOAD 模块卸载<br>4.4 RELOADXML 重新加载已经配置的XML<br>4.5 NOTIFY 通知<br>4.6 SEND_MESSAGE 发送信息<br>4.7 RECV_MESSAGE 接收信息<br>4.8 REQUEST_PARAMS 请求参数<br>4.9 CHANNEL_DATA 信道数据<br>4.10 GENERAL 总体<br>4.11 COMMAND 命令<br>4.12 SESSION_HEARTBEAT session心跳<br>4.13 CLIENT_DISCONNECTED 客户端断开<br>4.14 SERVER_DISCONNECTED 服务器断开<br>4.15 SEND_INFO 发送信息<br>4.16 RECV_INFO 接收信息<br>4.17 CALL_SECURE 保密呼叫<br>4.18 NAT nat<br>4.19 RECORD_START 开始记录<br>4.20 RECORD_STOP 停止记录<br>4.21 PLAYBACK_START 开始播放<br>4.22 PLAYBACK_STOP 停止播放<br>4.23 CALL_UPDATE 更新呼叫</uuid></p><p><a href="https://blog.csdn.net/hry2015/article/details/78347467" target="_blank" rel="noopener">https://blog.csdn.net/hry2015/article/details/78347467</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Freeswitch内核之事件类型&lt;/p&gt;
&lt;p&gt;事件 说明&lt;br&gt;3 Channel events 信道事件。&lt;br&gt;3.1 Channel states 信道状态。&lt;br&gt;3.2 CHANNEL_CALLSTATE 信道呼叫状态事件。&lt;br&gt;3.3 CHANNEL_CR
      
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Freeswitch" scheme="http://yoursite.com/tags/Freeswitch/"/>
    
  </entry>
  
  <entry>
    <title>voip名词</title>
    <link href="http://yoursite.com/2019/02/23/%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/02/23/名词/</id>
    <published>2019-02-23T06:22:53.000Z</published>
    <updated>2019-02-23T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ul><li><p>ASR：自动<em>语音识别</em>(Automatic Speech Recognition)</p></li><li><p>TTS：(Text To Speech,文本转语音)</p></li><li><p>IaaS：Infrastructure-as-a-Service(基础设施即服务)</p></li><li><p>PaaS：Platform-as-a-Service(平台即服务)</p></li><li><p>SaaS：Software-as-a-Service(软件即服务)</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;名词&quot;&gt;&lt;a href=&quot;#名词&quot; class=&quot;headerlink&quot; title=&quot;名词&quot;&gt;&lt;/a&gt;名词&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ASR：自动&lt;em&gt;语音识别&lt;/em&gt;(Automatic Speech Recognition)&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="voip" scheme="http://yoursite.com/tags/voip/"/>
    
  </entry>
  
  <entry>
    <title>voip网络核心设备SBC</title>
    <link href="http://yoursite.com/2019/02/23/Voip%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E8%AE%BE%E5%A4%87-SBC/"/>
    <id>http://yoursite.com/2019/02/23/Voip网络核心设备-SBC/</id>
    <published>2019-02-23T06:22:53.000Z</published>
    <updated>2019-02-23T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Voip网络核心设备-SBC"><a href="#Voip网络核心设备-SBC" class="headerlink" title="Voip网络核心设备-SBC"></a>Voip网络核心设备-SBC</h3><p>SBC（Session Border Controlle）是目前voip网络中的核心设备，中文意思是会话边界控制器。顾名思义，就是在网络边界处（内网和外网）对会话进行管理的设备。我们提到的会话是指SIP Session。</p><p><img src="http://s13.sinaimg.cn/large/001p2KAvzy7g3biBp92ec&amp;690" alt=""></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>SBC提供拓隐藏，呼叫路由管理，防攻击， NAT穿越， QOS， TDM接入， B2BUA，语音编码处理， SIP注册等。</p><p>SBC在VOIP网络环境中核心功能包括：</p><ul><li><p>SIP消息的规范话。在复杂的环境中，接入的设备终端可能来自不同的厂家，不同的私有协议标准，SBC必须对SIP消息进行规范化处理，确保其他的通信设备可以相互交互。</p></li><li><p>编码转换。</p></li><li><p>对NAT处理。</p></li><li><p>传真和语音检测功能。</p></li><li><p>具有良好的性能。</p></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>利用开源平台搭建SBC。openSIPS,kamailio,FreeSwtich。</p><p>kamailio + rtpproxy。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Voip网络核心设备-SBC&quot;&gt;&lt;a href=&quot;#Voip网络核心设备-SBC&quot; class=&quot;headerlink&quot; title=&quot;Voip网络核心设备-SBC&quot;&gt;&lt;/a&gt;Voip网络核心设备-SBC&lt;/h3&gt;&lt;p&gt;SBC（Session Border Con
      
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="voip" scheme="http://yoursite.com/tags/voip/"/>
    
  </entry>
  
  <entry>
    <title>erlang异常错误编程样式</title>
    <link href="http://yoursite.com/2019/02/23/erlang%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF%E7%BC%96%E7%A8%8B%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/23/erlang异常错误编程样式/</id>
    <published>2019-02-23T06:22:53.000Z</published>
    <updated>2019-02-23T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="try-catch-end和catch区别"><a href="#try-catch-end和catch区别" class="headerlink" title="try catch end和catch区别"></a>try catch end和catch区别</h3><ul><li><p>catch在try catch end引入之前就时erlang语言的一部分了。</p></li><li><p>异常错误如果发生在catch语句中，就会被转换成一个描述此错误的{‘EXIT’, …}元组。</p></li></ul><h3 id="异常错误编程样式"><a href="#异常错误编程样式" class="headerlink" title="异常错误编程样式"></a>异常错误编程样式</h3><ol><li><p>改进错误信息</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sqrt</span><span class="params">(X)</span> <span class="title">when</span> X &lt; 0 -&gt;</span></span><br><span class="line">    error(&#123;argument_error, X&#125;);</span><br><span class="line"><span class="function"><span class="title">sqrt</span><span class="params">(X)</span> -&gt;</span></span><br><span class="line">    match:sqrt(X).</span><br></pre></td></tr></table></figure></li><li><p>经常返回错误时代码</p><p>如果函数没有什么“通常的情形”，那么多半返回{ok, Val}或者{error, Reason}，这样迫使所有调用者必须对返回值做什么。一种代码编写：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> f(X) <span class="keyword">of</span></span><br><span class="line">    &#123;ok, Val&#125; -&gt;</span><br><span class="line">        do_some_thine_with(Val);</span><br><span class="line">    &#123;error, Why&#125; -&gt;</span><br><span class="line">        <span class="comment">%% ...处理错误....</span></span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>两种返回都要处理。</p><p>另一种代码编写：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;ok, Val&#125; = f(X),</span><br><span class="line"><span class="function"><span class="title">do_some_thing_with</span><span class="params">(Val)</span>.</span></span><br></pre></td></tr></table></figure><p>这样，如果f(X)返回错误，就会抛出错误。</p></li><li><p>错误可能有但罕见时的代码</p><p>这种情况下，通常要编写能够处理错误的代码。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> f(X)</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    throw:&#123;thisError, X&#125; -&gt; ....</span><br><span class="line">    throe:&#123;someOtherError, X&#125; -&gt; ....</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>f(X) 函数实现：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(X)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">case</span> ... <span class="keyword">of</span></span><br><span class="line">        ... -&gt;</span><br><span class="line">           Result;</span><br><span class="line">        ... -&gt;</span><br><span class="line">           throw(&#123;thisError,...&#125;);</span><br><span class="line">        ... -&gt;</span><br><span class="line">           throw(&#123;someOtherError,...&#125;) </span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></li><li><p>捕捉一切可能的异常错误</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> Expr </span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    _:_ ...  匹配处理所有异常</span><br><span class="line"><span class="keyword">end</span>       </span><br><span class="line">或者：</span><br><span class="line"><span class="keyword">try</span> Expr</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">    _ ... 默认只能处理throw:_ 类型的错误</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">generate_exception</span><span class="params">(<span class="number">1</span>)</span> -&gt;</span> a;</span><br><span class="line"><span class="function"><span class="title">generate_exception</span><span class="params">(<span class="number">2</span>)</span> -&gt;</span> throw(a);</span><br><span class="line"><span class="function"><span class="title">generate_exception</span><span class="params">(<span class="number">3</span>)</span> -&gt;</span> exit(a);</span><br><span class="line"><span class="function"><span class="title">generate_exception</span><span class="params">(<span class="number">4</span>)</span> -&gt;</span> &#123;'EXIT', a&#125;;  <span class="comment">%%模拟返回错误</span></span><br><span class="line"><span class="function"><span class="title">generate_exception</span><span class="params">(<span class="number">5</span>)</span> -&gt;</span> error(a).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">catcher</span><span class="params">(N)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">try</span> generate_exception(N) <span class="keyword">of</span></span><br><span class="line">        Val -&gt; &#123;N, normal, Val&#125;</span><br><span class="line">    <span class="keyword">catch</span> </span><br><span class="line">        throw:X -&gt; &#123;N, caught, throw, X&#125;;</span><br><span class="line">        exit:X -&gt; &#123;N, caught, exited, X&#125;;</span><br><span class="line">        error:X -&gt; &#123;N, caucaughtgth, error, X&#125;</span><br><span class="line">    <span class="keyword">end</span>.       </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="title">demo1</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [catcher(I) || I &lt;- lists:seq(<span class="number">1</span>,<span class="number">5</span>)].</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="title">demo2</span><span class="params">()</span> -&gt;</span></span><br><span class="line">[&#123;I, (catch generate_exception(I))&#125; || I &lt;- lists:seq(<span class="number">1</span>,<span class="number">5</span>)].</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>&gt; demo1().</span><br><span class="line">[&#123;<span class="number">1</span>,normal,a&#125;,</span><br><span class="line"> &#123;<span class="number">2</span>,caught,throw,a&#125;,</span><br><span class="line"> &#123;<span class="number">3</span>,caught,exited,a&#125;,</span><br><span class="line"> &#123;<span class="number">4</span>,normal,&#123;'EXIT',a&#125;&#125;,</span><br><span class="line"> &#123;<span class="number">5</span>,caught,error,a&#125;]</span><br><span class="line"><span class="number">3</span>&gt; demo2().</span><br><span class="line">[&#123;<span class="number">1</span>,a&#125;,</span><br><span class="line"> &#123;<span class="number">2</span>,a&#125;,</span><br><span class="line"> &#123;<span class="number">3</span>,&#123;'EXIT',a&#125;&#125;,</span><br><span class="line"> &#123;<span class="number">4</span>,&#123;'EXIT',a&#125;&#125;,</span><br><span class="line"> &#123;<span class="number">5</span>,</span><br><span class="line">  &#123;'EXIT',&#123;a,[&#123;a,generate_exception,<span class="number">1</span>,</span><br><span class="line">                 [&#123;file,<span class="string">"a.erl"</span>&#125;,&#123;line,<span class="number">7</span>&#125;]&#125;,</span><br><span class="line">              &#123;a,'-demo2/<span class="number">0</span>-lc$^<span class="number">0</span>/<span class="number">1</span>-<span class="number">0</span>-',<span class="number">1</span>,[&#123;file,<span class="string">"a.erl"</span>&#125;,&#123;line,<span class="number">19</span>&#125;]&#125;,</span><br><span class="line">              &#123;a,'-demo2/<span class="number">0</span>-lc$^<span class="number">0</span>/<span class="number">1</span>-<span class="number">0</span>-',<span class="number">1</span>,[&#123;file,<span class="string">"a.erl"</span>&#125;,&#123;line,<span class="number">19</span>&#125;]&#125;,</span><br><span class="line">              &#123;erl_eval,do_apply,<span class="number">6</span>,[&#123;file,<span class="string">"erl_eval.erl"</span>&#125;,&#123;line,<span class="number">674</span>&#125;]&#125;,</span><br><span class="line">              &#123;shell,exprs,<span class="number">7</span>,[&#123;file,<span class="string">"shell.erl"</span>&#125;,&#123;line,<span class="number">686</span>&#125;]&#125;,</span><br><span class="line">              &#123;shell,eval_exprs,<span class="number">7</span>,[&#123;file,<span class="string">"shell.erl"</span>&#125;,&#123;line,<span class="number">641</span>&#125;]&#125;,</span><br><span class="line">              &#123;shell,eval_loop,<span class="number">3</span>,[&#123;file,<span class="string">"shell.erl"</span>&#125;,&#123;line,<span class="number">626</span>&#125;]&#125;]&#125;&#125;&#125;]</span><br></pre></td></tr></table></figure><p>通过catch捕捉这三种异常返回的结果分别是：</p><p>  throw(Any) -&gt; Term</p><p>  exit(Reason) -&gt; {‘EXIT’,Reason}</p><p>  error(Reason) -&gt; {‘EXIT’,{Reason,erlang:get_stacktrace()}}</p><p>使用这三种异常的场景为：</p><p>exit(Reason): 当想要终止当前进程时，用这个函数。如果这个消息未被捕获，那么系统会向所有与当前进程连接的进程广告{‘EXIT’,Pid,Reason}消息</p><p>throw(Any): 用于抛出一个调用者可能会捕获的异常。针对throw，必须为函数添加注释，说明他会抛出这个异常。调用者可以选择：忽略这些异常/对异常进行处理。</p><p>error(Reason): 用于抛出那些“崩溃错误“。这种异常应该是调用者不会真正意识到要去处理的那些致命错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;try-catch-end和catch区别&quot;&gt;&lt;a href=&quot;#try-catch-end和catch区别&quot; class=&quot;headerlink&quot; title=&quot;try catch end和catch区别&quot;&gt;&lt;/a&gt;try catch end和catch区别&lt;/
      
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang异常错误编程样式" scheme="http://yoursite.com/tags/erlang%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF%E7%BC%96%E7%A8%8B%E6%A0%B7%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ivr知识</title>
    <link href="http://yoursite.com/2019/02/20/IVR%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/20/IVR知识/</id>
    <published>2019-02-20T12:04:23.000Z</published>
    <updated>2019-02-20T12:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自动外呼"><a href="#自动外呼" class="headerlink" title="自动外呼"></a>自动外呼</h3><p>用户下单后，外卖平台自动拨打商家电话，商家接通电话后播放ivr语音。</p><p>简单流程：播放订单信息后挂断。</p><p>复杂流程：商家根据播放语音选择按键，进入下一级ivr流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;自动外呼&quot;&gt;&lt;a href=&quot;#自动外呼&quot; class=&quot;headerlink&quot; title=&quot;自动外呼&quot;&gt;&lt;/a&gt;自动外呼&lt;/h3&gt;&lt;p&gt;用户下单后，外卖平台自动拨打商家电话，商家接通电话后播放ivr语音。&lt;/p&gt;
&lt;p&gt;简单流程：播放订单信息后挂断。&lt;/p&gt;

      
    
    </summary>
    
      <category term="CTI呼叫中心" scheme="http://yoursite.com/categories/CTI%E5%91%BC%E5%8F%AB%E4%B8%AD%E5%BF%83/"/>
    
    
      <category term="ivr知识" scheme="http://yoursite.com/tags/ivr%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>redis集群</title>
    <link href="http://yoursite.com/2019/02/20/redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/02/20/redis集群/</id>
    <published>2019-02-20T08:28:10.000Z</published>
    <updated>2019-02-20T11:59:05.899Z</updated>
    
    <content type="html"><![CDATA[<p>redis 单点、redis主从、redis哨兵sentinel、redis集群cluster配置搭建。</p><a id="more"></a><h3 id="redis单点"><a href="#redis单点" class="headerlink" title="redis单点"></a>redis单点</h3><p>编辑redis.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes   指定后台运行</span><br></pre></td></tr></table></figure><p>配置说明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">daemonize：如需要在后台运行，把该项的值改为yes</span><br><span class="line">pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址</span><br><span class="line"><span class="built_in">bind</span>：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</span><br><span class="line">port：监听端口，默认为6379</span><br><span class="line">timeout：设置客户端连接时的超时时间，单位为秒</span><br><span class="line">loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</span><br><span class="line">logfile：配置<span class="built_in">log</span>文件地址，默认使用标准输出，即打印在命令行终端的端口上</span><br><span class="line">database：设置数据库的个数，默认使用的数据库是0</span><br><span class="line">save：设置redis进行数据库镜像的频率</span><br><span class="line">rdbcompression：在进行镜像备份时，是否进行压缩</span><br><span class="line">dbfilename：镜像备份文件的文件名</span><br><span class="line">dir：数据库镜像备份的文件放置的路径</span><br><span class="line">slaveof：设置该数据库为其他数据库的从数据库</span><br><span class="line">masterauth：当主数据库连接需要密码验证时，在这里设定</span><br><span class="line">requirepass：设置客户端连接后进行任何其他指定前需要使用的密码</span><br><span class="line">maxclients：限制同时连接的客户端数量</span><br><span class="line">maxmemory：设置redis能够使用的最大内存</span><br><span class="line">appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态</span><br><span class="line">appendfsync：设置appendonly.aof文件进行同步的频率</span><br><span class="line">vm_enabled：是否开启虚拟内存支持</span><br><span class="line">vm_swap_file：设置虚拟内存的交换文件的路径</span><br><span class="line">vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</span><br><span class="line">vm_page_size：设置虚拟内存页的大小</span><br><span class="line">vm_pages：设置交换文件的总的page数量</span><br><span class="line">vm_max_thrrads：设置vm IO同时使用的线程数量</span><br></pre></td></tr></table></figure><h3 id="redis主从"><a href="#redis主从" class="headerlink" title="redis主从"></a>redis主从</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-master-slave</span><br><span class="line">cp path/to/redis/conf/redis.conf path/to/redis-master-slave master.conf</span><br><span class="line">cp path/to/redis/conf/redis.conf path/to/redis-master-slave slave.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">## master.conf</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">## slave.conf</span></span><br><span class="line">port 6380</span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>启动主从redis，打开两个命令窗口执行info</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br></pre></td></tr></table></figure><p>主节点set数据后，可以在从节点get数据，但是在从节点不可以set</p><h3 id="哨兵sentinel"><a href="#哨兵sentinel" class="headerlink" title="哨兵sentinel"></a>哨兵sentinel</h3><p>上面我们介绍了主从，从库作为一个“傀儡”，可以在需要的时候“顶上来”，”接盘“。我们配置的主从是为了”有备无患“，在主redis挂了之后，可以立马切换到从redis上，可能只需要花几分钟的时间，但是仍然是需要人为操作。这个时候redis sentinel 就派上用场了。sentinel 通常翻译成哨兵，就是放哨的，这里它就是用来监控主从节点的健康情况。客户端连接redis主从的时候，先连接 sentinel，sentinel会告诉客户端主redis的地址是多少，然后客户端连接上redis并进行后续的操作。当主节点挂掉的时候，客户端就得不到连接了因而报错了，客户端重新想sentinel询问主master的地址，然后客户端得到了新选举出来的主redis，然后又可以愉快的操作了。</p><p>为了说明sentinel的用处，我们做个试验。配置3个redis（1主2从），1个哨兵。步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-sentinel</span><br><span class="line"><span class="built_in">cd</span> redis-sentinel</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis01.conf</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis02.conf</span><br><span class="line">cp redis/path/conf/redis.conf path/to/redis-sentinel/redis03.conf</span><br><span class="line">touch sentinel.conf</span><br></pre></td></tr></table></figure><p>上我们创建了 3个redis配置文件，1个哨兵配置文件。我们将 redis01设置为master,将redis02，redis03设置为slave。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim redis01.conf</span><br><span class="line">port 63791</span><br><span class="line"></span><br><span class="line">vim redis02.conf</span><br><span class="line">port 63792</span><br><span class="line">slaveof 127.0.0.1 63791</span><br><span class="line"></span><br><span class="line">vim redis03.conf</span><br><span class="line">port 63793</span><br><span class="line">slaveof 127.0.0.1 63791</span><br><span class="line"></span><br><span class="line">vim sentinel.conf</span><br><span class="line">daemonize yes</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 63791 1</span><br></pre></td></tr></table></figure><p>哨兵配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">protected-mode no</span><br><span class="line">pidfile <span class="string">"/usr/local/redis/var/redis-sentinel.pid"</span></span><br><span class="line">dir <span class="string">"/usr/local/redis/data/sentinel"</span></span><br><span class="line">daemonize yes</span><br><span class="line">logfile <span class="string">"/usr/local/redis/var/redis-sentinel.log"</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 63791 1</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 18000</span><br><span class="line">sentinel auth-pass mymaster admin</span><br><span class="line">sentinel failover-timeout mymaster 18000</span><br><span class="line">sentinel auth-pass mymaster admin</span><br></pre></td></tr></table></figure><p>mymaster 为主节点名字，可以随便取，后面程序里边连接的时候要用到 127.0.0.1 63793 为主节点的 ip,port 1 后面的数字 1 表示选举主节点的时候，投票数。1表示有一个sentinel同意即可升级为master。</p><p>主节点宕机模拟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始情况下，1主2从</span><br><span class="line"><span class="comment"># +monitor master mymaster 127.0.0.1 63791 quorum 1</span></span><br><span class="line">* +slave slave 127.0.0.1:63792 127.0.0.1 63792 @ mymaster 127.0.0.1 63791</span><br><span class="line">* +slave slave 127.0.0.1:63793 127.0.0.1 63793 @ mymaster 127.0.0.1 63791</span><br><span class="line">发现主挂了，准备 故障转移</span><br><span class="line"><span class="comment"># +try-failover master mymaster 127.0.0.1 63791</span></span><br><span class="line">将主切换到了 63793 即redis03 </span><br><span class="line"><span class="comment"># +switch-master mymaster 127.0.0.1 63791 127.0.0.1 63793</span></span><br></pre></td></tr></table></figure><p>切换异常：30367:X 17 Oct 13:24:11.578 # -failover-abort-not-elected master mymaster 127.0.0.1 63793</p><p>解决：如果redis.conf配置中配置了</p><p>protected-mode yes</p><p>bind 192.168.98.136</p><p>则需要在sentinel 配置文件加上protected-mode no</p><p>否则在sentinel 配置文件加上</p><p>protected-mode yes  </p><p>bind 192.168.98.136</p><h3 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h3><ul><li><p>单个redis并发有限</p></li><li><p>单个redis内存有限，内存太大导致rdb文件过大，同步回复数据会很慢。</p></li></ul><p>所有，我们需要redis cluster 即redis集群。</p><p>Redis 集群是一个提供在<strong>多个Redis间节点间共享数据</strong>的程序集。</p><p>Redis 集群并不支持处理多个keys的命令,因为这需要在不同的节点间移动数据,从而达不到像Redis那样的性能,在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供<strong>一定程度的可用性</strong>,在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><ul><li><p>自动分割数据到不同的节点上。</p></li><li><p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p></li></ul><p>因为最小的redis集群，需要至少3个主节点，既然有3个主节点，而一个主节点搭配至少一个从节点，因此至少得6台redis。</p><p>创建redis集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-5.0.3/src/redis-cli --cluster create 127.0.0.1:6371 127.0.0.1:6372 127.0.0.1:6373 127.0.0.1:6374 127.0.0.1:6375 127.0.0.1:6376 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>集群管理界面：Relumin</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redis 单点、redis主从、redis哨兵sentinel、redis集群cluster配置搭建。&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="redis集群" scheme="http://yoursite.com/tags/redis%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq集群</title>
    <link href="http://yoursite.com/2019/02/20/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/02/20/rabbitmq集群/</id>
    <published>2019-02-20T06:38:10.000Z</published>
    <updated>2019-02-20T11:48:38.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>RabbitMQ集群中可以共享user，virtualhosts，queues，exchanges等。但message只会在创建的节点上传输。当message进入A节点的queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。<br>RABBITMQ的集群节点包括内存节点、磁盘节点。内存节点的元数据仅放在内存中，性能比磁盘节点会有所提升。不过，如果在投递message时，打开了message的持久化，那么内存节点的性能只能体现在资源管理上，比如增加或删除队列（queue），虚拟主机（vrtual hosts），交换机（exchange）等，发送和接受message速度同磁盘节点一样。一个集群至少要有一个磁盘节点。<br><a id="more"></a></p><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><ul><li><p>cookie同步</p><p>同步/var/lib/rabbitmq/erlang.cookie，本文件默认权限400。</p></li><li><p>加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit@tabbitmq1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>查看集群信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure></li><li><p>更改节点属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl change_cluster_node_type disc/ram</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li><li><p>节点退出集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">退出节点服务执行：</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">集群主节点执行：</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@rabbitmq2</span><br></pre></td></tr></table></figure></li><li><p>rabbitmq集群重启</p><p>集群重启时，最后一个挂掉的节点应该第一个重启，如果因特殊原因（比如同时断电），而不知道哪个节点最后一个挂掉。可用以下方法重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl force_boot</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">在其他节点上执行</span><br><span class="line">service rabbitmq-server start</span><br><span class="line">查看cluster状态是否正常（要在所有节点上查询）。</span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>如果有节点没加入集群，可以先退出集群，然后再重新加入集群。上述方法不适合内存节点重启，内存节点重启的时候是会去磁盘节点同步数据，如果磁盘节点没起来，内存节点一直失败。</p></li></ul><h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>镜像队列可以同步queue和message，当主queue挂掉，从queue中会有一个变为主queue来接替工作。</p><p>镜像队列是基于普通的集群模式的,所以你还是得先配置普通集群,然后才能设置镜像队列。</p><p>镜像队列设置后，会分一个主节点和多个从节点，如果主节点宕机，从节点会有一个选为主节点，原先的主节点起来后会变为从节点。</p><p>queue和message虽然会存在所有镜像队列中，但客户端读取时不论物理面连接的主节点还是从节点，都是从主节点读取数据，然后主节点再将queue和message的状态同步给从节点，因此多个客户端连接不同的镜像队列不会产生同一message被多次接受的情况。</p><p>#rabbitmqctl set_policy  ha-all “hello” ‘{“ha-mode”:”all”}’</p><p>ha-all 是同步模式，指同步给所有节点，还有另外两种模式ha-exactly表示在指定个数的节点上进行镜像，节点的个数由ha-params指定，ha-nodes表示在指定的节点上进行镜像，节点名称通过ha-params指定；</p><p>hello 是同步的队列名，可以用正则表达式匹配；</p><p>{“ha-mode”:”all”} 表示同步给所有，同步模式的不同，此参数也不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h3&gt;&lt;p&gt;RabbitMQ集群中可以共享user，virtualhosts，queues，exchanges等。但message只会在创建的节点上传输。当message进入A节点的queue中后，consumer从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。&lt;br&gt;RABBITMQ的集群节点包括内存节点、磁盘节点。内存节点的元数据仅放在内存中，性能比磁盘节点会有所提升。不过，如果在投递message时，打开了message的持久化，那么内存节点的性能只能体现在资源管理上，比如增加或删除队列（queue），虚拟主机（vrtual hosts），交换机（exchange）等，发送和接受message速度同磁盘节点一样。一个集群至少要有一个磁盘节点。&lt;br&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="rabbitmq集群" scheme="http://yoursite.com/tags/rabbitmq%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA使用</title>
    <link href="http://yoursite.com/2019/02/13/IntellijIDEA%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/13/IntellijIDEA使用/</id>
    <published>2019-02-13T09:27:28.000Z</published>
    <updated>2019-02-13T09:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>关闭自动更新</p><p>Intellij IDEA -&gt; Preferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates 下取消 Automatically check updates for勾选</p></li><li><p>代码编辑器主题风格</p><p>Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Font</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scheme: Darcula</span><br><span class="line">Show only monospaced fonts 设置第一字体，Monaco 不支持中文</span><br><span class="line">    Primary font:Monaco Size:<span class="number">20</span> Line spacing:<span class="number">1.0</span></span><br><span class="line">Secondary font：YaHei Consolas Hybrid  设置第二字体</span><br></pre></td></tr></table></figure></li><li><p>文件编码</p><p>File -&gt; Settings -&gt; Editor -&gt; File Encodings</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Global Encoding:UTF-<span class="number">8</span></span><br><span class="line">Projectt Encoding:UTF-<span class="number">8</span></span><br><span class="line">Default encoding <span class="keyword">for</span> properties files:UTF-<span class="number">8</span></span><br><span class="line">勾选上Transparent native-to-ascii conversion</span><br></pre></td></tr></table></figure></li><li><p>类和方法注视模版</p><p>在File -&gt; Settings -&gt; Editor -&gt; File and Code Templates</p></li><li><p>编码缩进</p><p>Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Code Style -&gt; Erlang</p><p>Use tab character 不要勾选，然后indent设置为4，代表按一个tab为4个空格，并且自动整理格式也是4个空格一缩进。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tab size: <span class="number">4</span> </span><br><span class="line">Indent: <span class="number">4</span></span><br><span class="line">Continuation indent: <span class="number">8</span></span><br></pre></td></tr></table></figure><p>如果要对多个文件进行转换，可以在文件夹上面按右键，然后点击Reformat Code或者选中文件夹按快捷键ctrl+alt+L对多个快捷键整理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;关闭自动更新&lt;/p&gt;
&lt;p&gt;Intellij IDEA -&amp;gt; Preferences -&amp;gt; Appearance &amp;amp; Behavior -&amp;gt; System Settings -&amp;gt; Updates 下取消 Automatica
      
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="http://yoursite.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq知识</title>
    <link href="http://yoursite.com/2019/02/13/rabbitmq%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/02/13/rabbitmq知识/</id>
    <published>2019-02-13T09:23:39.000Z</published>
    <updated>2019-02-20T09:12:56.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h3><p>RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述）</p><ul><li>fanout</li></ul><p>转发消息到所有绑定队列。</p><ul><li>direct</li></ul><p>把消息路由到那些binding key与routing key完全匹配的Queue中。</p><ul><li>headers</li></ul><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。</p><ul><li>topic</li></ul><p>topic类型的Exchange在匹配规则上进行了扩展。</p><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”。</p><p>binding key与routing key一样也是句点号“. ”分隔的字符串。</p><p>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。</p><h3 id="RabbitMQ-RPC"><a href="#RabbitMQ-RPC" class="headerlink" title="RabbitMQ RPC"></a>RabbitMQ RPC</h3><p><img src="https://cdn.www.sojson.com/file/doc/6121174952" alt=""></p><p><a href="http://www.sojson.com/tag_rabbitmq.html" title="RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a> 中实现<code>RPC</code>的机制是：</p><ul><li><p>客户端发送请求（消息）时，在消息的属性（<code>MessageProperties</code>，在<code>AMQP</code>协议中定义了14中<code>properties</code>，这些属性会随着消息一起发送）中设置两个值<code>replyTo</code>（一个<code>Queue</code>名称，用于告诉服务器处理完成后将通知我的消息发送到这个<code>Queue</code>中）和<code>correlationId</code>（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）</p></li><li><p>服务器端收到消息并处理</p></li><li><p>服务器端处理完消息后，将生成一条应答消息到<code>replyTo</code>指定的<code>Queue</code>，同时带上<code>correlationId</code>属性</p></li><li><p>客户端之前已订阅<code>replyTo</code>指定的<code>Queue</code>，从中收到服务器的应答消息后，根据其中的<code>correlationId</code>属性分析哪条请求被执行了，根据执行结果进行后续业务处理</p></li></ul><h3 id="RabbitMQ-选型和对比"><a href="#RabbitMQ-选型和对比" class="headerlink" title="RabbitMQ 选型和对比"></a>RabbitMQ 选型和对比</h3><p>1.从社区活跃度</p><p>按照目前网络上的资料，<code>RabbitMQ</code>、<code>activeM</code>、<code>ZeroMQ</code>三者中，综合来看，<code>RabbitMQ</code>是首选。</p><p>2.持久化消息比较</p><p><code>ZeroMq</code>不支持，<code>ActiveMq</code>和<code>RabbitMq</code>都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。</p><p>3.综合技术实现</p><p>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。</p><p><code>RabbitMq</code>/<code>Kafka</code>最好，<code>ActiveMq</code>次之，<code>ZeroMq</code>最差。当然<code>ZeroMq</code>也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</p><p> 4.高并发</p><p>毋庸置疑，<code>RabbitMQ</code>最高，原因是它的实现语言是天生具备高并发高可用的<code>erlang</code>语言。</p><p> 5.比较关注的比较，RabbitMQ和 Kafka</p><p><code>RabbitMq</code>比<code>Kafka</code>成熟，在可用性上，稳定性上，可靠性上， <a href="http://www.sojson.com/tag_rabbitmq.html" title="RabbitMq" target="_blank" rel="noopener">RabbitMq</a> 胜于 <a href="http://www.sojson.com/tag_kafka.html" title="Kafka" target="_blank" rel="noopener">Kafka</a> （理论上）。</p><p>另外，<code>Kafka</code>的定位主要在日志等方面， 因为<code>Kafka</code>设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择<code>RabbitMq</code>。</p><h3 id="RabbitMQ-Erlang-Client"><a href="#RabbitMQ-Erlang-Client" class="headerlink" title="RabbitMQ Erlang Client"></a>RabbitMQ Erlang Client</h3><p><a href="http://www.rabbitmq.com/erlang-client.html" title="Amqp Erlang Client" target="_blank" rel="noopener">Amqp Erlang Client</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RabbitMQ简介&quot;&gt;&lt;a href=&quot;#RabbitMQ简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ简介&quot;&gt;&lt;/a&gt;RabbitMQ简介&lt;/h3&gt;&lt;p&gt;RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;p&gt;AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
    
    </summary>
    
      <category term="开源框架" scheme="http://yoursite.com/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>java安装</title>
    <link href="http://yoursite.com/2019/02/13/java%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/02/13/java安装/</id>
    <published>2019-02-13T09:23:39.000Z</published>
    <updated>2019-02-20T06:33:05.355Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>java 1.8 安装</p><p>yum install yum install java-1.8.0-openjdk-devel.x86_64</p></li><li><p>java 环境变量</p><p>CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HOME</span>/bin:<span class="variable">$HOME</span>/.<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>java 1.8 安装</p><p>yum install yum install java-1.8.0-openjdk-devel.x86_64</p></li><li><p>java 环境变量</p><p>CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0</span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$HOME</span>/bin:<span class="variable">$HOME</span>/.<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>java 安装目录信息</p><p>dt.jar中包含了关于swing的控件对应的图标和BeanInfo.class</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jvm-exports/java</span><br><span class="line">/usr/lib/java</span><br><span class="line">/usr/lib/jvm/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/jre/bin/java</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/bin/java</span><br><span class="line">/usr/share/java</span><br><span class="line">/usr/bin/java</span><br><span class="line">/var/lib/alternatives/java</span><br><span class="line">/etc/pki/java</span><br><span class="line">/etc/pki/ca-trust/extracted/java</span><br><span class="line">/etc/java</span><br><span class="line">/etc/alternatives/java</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;java 1.8 安装&lt;/p&gt;
&lt;p&gt;yum install yum install java-1.8.0-openjdk-devel.x86_64&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java 环境变量&lt;/p&gt;
&lt;p&gt;CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等；&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;variable&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JAVA_HOME=/usr/lib/jvm/java-1.8.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLASSPATH=.:&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/lib/tools.jar:&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/lib/dt.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;variable&quot;&gt;$JAVA_HOME&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/.&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/bin:&lt;span class=&quot;variable&quot;&gt;$PATH&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>sysctl.conf调整</title>
    <link href="http://yoursite.com/2019/01/08/linux-sysctl%E8%B0%83%E6%95%B4/"/>
    <id>http://yoursite.com/2019/01/08/linux-sysctl调整/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>设置tcp参数一定要小心谨慎,轻易不要更改线上环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">et.ipv4.tcp_tw_reuse    = 1 </span><br><span class="line">net.ipv4.tcp_tw_recycle  = 1 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800 </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096 </span><br><span class="line">net.ipv4.tcp_syncookies = 1 www.2cto.com</span><br></pre></td></tr></table></figure><p>执行 /sbin/sysctl -p 让参数生效。</p><a id="more"></a><ol><li><p>大量TIME_WAIT问题</p><p>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.</p><p>解决方案：</p><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p><p>net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间。</p></li><li><p>参数说明</p><p>tcp_syn_retries ：INTEGER</p><p>默认值是5</p><p>对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1 决定的)</p><p>tcp_synack_retries ：INTEGER</p><p>默认值是5</p><p>对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的tcp_syn_retries来决定这个值)</p><p>tcp_keepalive_time ：INTEGER</p><p>默认值是7200(2小时)</p><p>当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击?tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒)</p><p>tcp_keepalive_probes：INTEGER</p><p>默认值是9</p><p>TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适)</p><p>tcp_keepalive_intvl：INTEGER</p><p>默认值为75</p><p>探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</p><p>tcp_retries1 ：INTEGER</p><p>默认值是3</p><p>放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)</p><p>tcp_retries2 ：INTEGER</p><p>默认值为15</p><p>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</p><p>tcp_orphan_retries ：INTEGER</p><p>默认值是7</p><p>在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</p><p>tcp_fin_timeout ：INTEGER</p><p>默认值是 60</p><p>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。 过去在2.2版本的内核中是 180 秒。您可以设置该值﹐但需要注意﹐如果您的机器为负载很重的web服务器﹐您可能要冒内存被大量无效数据报填满的风险﹐FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ﹐因为它们最多只吃 1.5K 的内存﹐但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30)</p><p>tcp_max_tw_buckets ：INTEGER</p><p>默认值是180000</p><p>系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要人为的降低这个限制﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</p><p>tcp_tw_recycle ：BOOLEAN</p><p>默认值是0</p><p>打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</p><p>tcp_tw_reuse：BOOLEAN</p><p>默认值是0</p><p>该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</p><p>tcp_max_orphans ：INTEGER</p><p>缺省值是8192</p><p>系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</p><p>tcp_abort_on_overflow ：BOOLEAN</p><p>缺省值是0</p><p>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</p><p>tcp_syncookies ：BOOLEAN</p><p>默认值是0</p><p>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</p><p>注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考:</p><p>tcp_max_syn_backlog</p><p>tcp_synack_retries</p><p>tcp_abort_on_overflow</p><p>syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.)</p><p>tcp_stdurg ：BOOLEAN</p><p>默认值为0</p><p>使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在Linux打开它﹐或会导致不能和它们正确沟通。</p><p>tcp_max_syn_backlog ：INTEGER</p><p>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于1024﹐最好修改 include/net/tcp.h 里面的 TCP_SYNQ_HSIZE ﹐以保持TCP_SYNQ_HSIZE*16&lt;=tcp_max_syn_backlog ﹐并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有 效的缓解小规模的SYN Flood攻击(事实证明&lt;1000p/s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.)</p><p>tcp_window_scaling ：INTEGER</p><p>缺省值为1</p><p>该文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）</p><p>tcp_timestamps ：BOOLEAN</p><p>缺省值为1</p><p>Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</p><p>tcp_sack ：BOOLEAN</p><p>缺省值为1</p><p>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</p><p>tcp_fack ：BOOLEAN</p><p>缺省值为1</p><p>打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)</p><p>tcp_dsack ：BOOLEAN</p><p>缺省值为1</p><p>允许TCP发送”两个完全相同”的SACK。</p><p>tcp_ecn ：BOOLEAN</p><p>缺省值为0</p><p>打开TCP的直接拥塞通告功能。</p><p>tcp_reordering ：INTEGER</p><p>默认值是3</p><p>TCP流中重排序的数据报最大数量 。 (一般有看到推荐把这个数值略微调整大一些,比如5)</p><p>tcp_retrans_collapse ：BOOLEAN</p><p>缺省值为1</p><p>对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它)</p><p>tcp_wmem(3个INTEGER变量)： min, default, max</p><p>min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。</p><p>default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。</p><p>max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）</p><p>tcp_rmem (3个INTEGER变量)： min, default, max</p><p>min：为TCP socket预留用于接收缓冲的内存数量，即使在内存出现紧张情况下tcp socket都至少会有这么多数量的内存用于接收缓冲，默认值为8K。</p><p>default：为TCP socket预留用于接收缓冲的内存数量，默认情况下该值影响其它协议使用的net.core.wmem_default 值。该值决定了在tcp_adv_win_scale、tcp_app_win和tcp_app_win=0默认值情况下，TCP窗口大小为65535。默认值为87380</p><p>max：用于TCP socket接收缓冲的内存最大值。该值不会影响 net.core.wmem_max，”静态”选择参数 SO_SNDBUF则不受该值影响。默认值为 128K。默认值为87380*2 bytes。（可以看出，.max的设置最好是default的两倍,对于NAT来说主要该增加它,我的网络里为 51200 131072 204800）</p><p>tcp_mem(3个INTEGER变量)：low, pressure, high</p><p>low：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 / 4096)。 )</p><p>pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 * 300 / 4096)。 )</p><p>high：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000)</p><p>一般情况下这些值是在系统启动时根据系统内存数量计算得到的。</p><p>tcp_app_win : INTEGER</p><p>默认值是31</p><p>保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。</p><p>tcp_adv_win_scale : INTEGER</p><p>默认值为2</p><p>计算缓冲开销bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale &lt;= 0）。</p><p>tcp_rfc1337 :BOOLEAN</p><p>缺省值为0</p><p>这个开关可以启动对于在RFC1337中描述的”tcp 的time-wait暗杀危机”问题的修复。启用后，内核将丢弃那些发往time-wait状态TCP套接字的RST 包.</p><p>tcp_low_latency : BOOLEAN</p><p>缺省值为0</p><p>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建Beowulf 集群的时候,打开它很有帮助)</p><p>tcp_westwood :BOOLEAN</p><p>缺省值为0</p><p>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项。</p><p>tcp_bic :BOOLEAN</p><p>缺省值为0</p><p>为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设置tcp参数一定要小心谨慎,轻易不要更改线上环境。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;et.ipv4.tcp_tw_reuse    = 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_tw_recycle  = 1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_fin_timeout = 30 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_keepalive_time = 1800 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_max_syn_backlog = 4096 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.tcp_syncookies = 1 www.2cto.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行 /sbin/sysctl -p 让参数生效。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-sysctl" scheme="http://yoursite.com/tags/linux-sysctl/"/>
    
  </entry>
  
  <entry>
    <title>erlang知识点记录</title>
    <link href="http://yoursite.com/2019/01/08/erlang%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/01/08/erlang知识点记录/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>gen_server:cast和erlang:send()都可以向指定进程发送消息，两者有什么区别？</p><p>gen_server:cast 内部调用erlang:send使用noconnect</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">catch</span> erlang:send(Dest, Msg, [noconnect]) <span class="keyword">of</span></span><br><span class="line">    noconnect -&gt;</span><br><span class="line">        spawn(erlang, send, [Dest,Msg]);</span><br><span class="line">    Other -&gt;</span><br><span class="line">        Other</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span> erlang:send<span class="params">(Dest, Msg, Options)</span> -&gt; Res when</span><br><span class="line">      Dest :: dst<span class="params">()</span>,</span><br><span class="line">      Msg :: term<span class="params">()</span>,</span><br><span class="line">      Options :: [nosuspend | noconnect],</span><br><span class="line">      Res :: ok | nosuspend | noconnect.</span><br></pre></td></tr></table></figure><p>nosuspend：遇到会挂起进程时不挂起进程，直接返回nosuspend</p><p>noconnect：遇到远程节点没有连接时不自动连接发送消息，直接返回noconnect</p></li></ol><a id="more"></a><ol start="2"><li><p>gen_server:call</p></li><li><p>rpc:call和gen_server:call 区别？</p><p>rpc模块本身就是gen_server进程，随kernel模块启动，rpc进程启动时通过local注册一个rex的名字。</p><p>rpc:call内部调用gen_server:call({Name,Node},Request)，Name是rex，所以说rpc:call是调用远程节点的rex进程做事情，而gen_server:call可以调用任意进程做事情。</p></li><li><p>erlang:now()和os:timestamp()区别？</p><p>erlang:now()获取erlang虚拟机时间，os:timestamp()获取操作系统时间，对于erlang:start_time函数如果调快系统时间，此定时不会提前收到消息。因为erlang:start_time内部使用erlang虚拟机时间。</p></li><li><p>erlang:send_after和erlang:start_time区别？</p><p>主要是TimerRef，超时消息进入邮箱时，start_time函数的消息携带了TimeRef标识。</p></li><li><p>ref数据类型</p><p>Erlang 虚拟机会创建一个新的 ref。由于全局当前 ref 值是用多个变量表示的，所以 make_ref() 会通过一个自旋锁保护对这些变量的操作，递增全局 ref 的值，然后根据新的 ref 值创建新的 ref 对象并返回对应的 Eterm。递增操作针对 word 0 递增，如果 word 0 超过了218218，则进位到 word 1，word 1 归零的话则进位到 word 2。</p><p>我们打印 ref 的时候，得到的是类似 #Ref&lt;0.0.0.2055&gt; 这样的输出，通过 3 个句点将输出结果分为 4 段。第 1 段，和 pid 和 port 的第一段是一样的，表示节点，在本地节点总是为 0，后面 3 段分别为上面的 word 2、1 和 0。所以 ref 较少的时候前面几段都为 0。</p></li><li><p>ets表</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span> new<span class="params">(Name, Options)</span> -&gt; tid<span class="params">()</span> | atom<span class="params">()</span> when</span><br><span class="line">      Name :: atom<span class="params">()</span>,</span><br><span class="line">      Options :: [Option],</span><br><span class="line">      Option :: Type | Access | named_table | &#123;keypos,Pos&#125;</span><br><span class="line">              | &#123;heir, Pid :: pid<span class="params">()</span>, HeirData&#125; | &#123;heir, none&#125; | Tweaks,</span><br><span class="line">      Type :: type<span class="params">()</span>,</span><br><span class="line">      Access :: access<span class="params">()</span>,</span><br><span class="line">      Tweaks :: &#123;write_concurrency, boolean<span class="params">()</span>&#125;</span><br><span class="line">              | &#123;read_concurrency, boolean<span class="params">()</span>&#125;</span><br><span class="line">              | compressed,</span><br><span class="line">      Pos :: pos_integer<span class="params">()</span>,</span><br><span class="line">      HeirData :: term<span class="params">()</span>.</span><br></pre></td></tr></table></figure><p>write_concurrency、read_concurrency是用来提升读写性能的，代价是额外的内存。并不是支持读和写的并发控制的，因为ets本身的读写操作就是原子的。通常来说，<strong>ets写数据时整张表是锁定的</strong>，其他进程不能进行读写直到前面的操作完成。并发写可以改变这个情况，<strong>同一个表中的不同记录可以被多个进程并发读写</strong>。有了这个参数，使得ets写记录时表读写锁变成了读锁，就是说，只要不是同一条记录，还可以继续往这个ets表写入数据，提高了并发写效率。但并发写也有弊端，降低数据连续写入的效率和性能。如果有且只有一个进程在读写数据，将会带来一定的开销。而测试发现这个开销比较小，可以忽略。而且，只有一个进程在读写数据的场合比较小。</p></li><li><p>Pid &lt;A,B,C&gt;</p><p>A对应节点信息（0代表本地节点，其他数字代表远程节点）</p><p>B低15字节代表进程表索引</p><p>C16～18字节代表进程唯一标识</p></li><li><p>erlang:dbg、trace、火焰图</p></li><li><p>receive的理解</p><p>receive会检查遍历进程的邮箱一次，如果匹配到条件，就执行条件后的代码，并去掉邮箱中对应消息，停止匹配过程。等待下一条消息到达时触发再次匹配逻辑。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;gen_server:cast和erlang:send()都可以向指定进程发送消息，两者有什么区别？&lt;/p&gt;
&lt;p&gt;gen_server:cast 内部调用erlang:send使用noconnect&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; erlang:send(Dest, Msg, [noconnect]) &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    noconnect -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        spawn(erlang, send, [Dest,Msg]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Other -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Other&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;-spec&lt;/span&gt; erlang:send&lt;span class=&quot;params&quot;&gt;(Dest, Msg, Options)&lt;/span&gt; -&amp;gt; Res when&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Dest :: dst&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Msg :: term&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Options :: [nosuspend | noconnect],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Res :: ok | nosuspend | noconnect.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;nosuspend：遇到会挂起进程时不挂起进程，直接返回nosuspend&lt;/p&gt;
&lt;p&gt;noconnect：遇到远程节点没有连接时不自动连接发送消息，直接返回noconnect&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang" scheme="http://yoursite.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>tcp参数调优</title>
    <link href="http://yoursite.com/2019/01/08/tcp%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2019/01/08/tcp参数调优/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>/etc/sysctl.conf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535</span><br><span class="line">net.core.rmem_max=16777216</span><br><span class="line">net.core.wmem_max=16777216</span><br><span class="line">net.ipv4.tcp_rmem=4096 87380 16777216</span><br><span class="line">net.ipv4.tcp_wmem=4096 65536 16777216</span><br><span class="line">net.ipv4.tcp_fin_timeout = 10</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.ipv4.tcp_window_scaling = 0</span><br><span class="line">net.ipv4.tcp_sack = 0</span><br><span class="line">net.core.netdev_max_backlog = 30000</span><br><span class="line">net.ipv4.tcp_no_metrics_save=1</span><br><span class="line">net.core.somaxconn = 262144</span><br><span class="line">net.ipv4.tcp_syncookies = 0</span><br><span class="line">net.ipv4.tcp_max_orphans = 262144</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line"></span><br><span class="line">fs.file-max = 1024000</span><br><span class="line">net.nf_conntrack_max= 1024000</span><br><span class="line">net.ipv4.tcp_mem=786432 2097152 3145728</span><br></pre></td></tr></table></figure><ol start="2"><li><p>ulimit -a 中open files (-n) 1024000 修改</p><p>vi /etc/profile</p><p>ulimit -n 1024000</p><p>生效：source /etc/profile</p><p>cat /proc/sys/fs/file-max</p><p>修改：pending signals (-i) 128296</p><p>vi /etc/profile</p><p>ulimit -i 128296</p><p>生效：source /etc/profile</p></li><li><p>error, emfile 最大用户进程需要在90-nproc.conf</p><p>vi /etc/security/limits.conf</p><p>soft nofile 65535</p><p>hard nofile 65535</p><p>然后，一般来说，修改ulimit的数值，只需要修改/etc/security/limits.conf即可，但是这个参数需要修改/etc/security/limits.d/90-nproc.conf。centos 6.<em>可以修改/etc/security/limits.d/90-nproc.conf，但centos 5.</em>并没有90-nproc.conf这个文件，我这边是通过修改/etc/security/limits.conf。</p></li><li><p>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</p><p>CLOSE_WAIT 162</p><p>ESTABLISHED 10163</p><p>SYN_RECV 242</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;/etc/sysctl.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-sysctl" scheme="http://yoursite.com/tags/linux-sysctl/"/>
    
  </entry>
  
  <entry>
    <title>vimdiff</title>
    <link href="http://yoursite.com/2019/01/08/vimdiff/"/>
    <id>http://yoursite.com/2019/01/08/vimdiff/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>##实用的vim下比较两个文件命令：</p><h3 id="1、-vimdiff-file1-file2"><a href="#1、-vimdiff-file1-file2" class="headerlink" title="1、 vimdiff file1 file2"></a>1、 vimdiff file1 file2</h3><p>终端下输入该命令进入vim，垂直分隔窗口进行比较</p><h3 id="2、-vimdiff-o-file1-file2"><a href="#2、-vimdiff-o-file1-file2" class="headerlink" title="2、 vimdiff -o file1 file2"></a>2、 vimdiff -o file1 file2</h3><p>水平分隔窗口进行比较</p><h3 id="3、-ctrl-w-j-k-h-l"><a href="#3、-ctrl-w-j-k-h-l" class="headerlink" title="3、 ctrl+w (j,k,h,l)"></a>3、 ctrl+w (j,k,h,l)</h3><p>上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l）</p><h3 id="4、-ctrl-w-J-K-H-L"><a href="#4、-ctrl-w-J-K-H-L" class="headerlink" title="4、 ctrl+w (J,K,H,L)"></a>4、 ctrl+w (J,K,H,L)</h3><p>上下左右移动光标所在窗口的位置</p><a id="more"></a><h3 id="5、-zo-和-zc"><a href="#5、-zo-和-zc" class="headerlink" title="5、 zo 和 zc"></a>5、 zo 和 zc</h3><p>打开折叠区 和 关闭折叠区</p><h3 id="6、-c-和-c"><a href="#6、-c-和-c" class="headerlink" title="6、 ]c 和 [c"></a>6、 ]c 和 [c</h3><p>将光标移动到下一个不同区 和 上一个不同区</p><h3 id="7、-do-和-dp"><a href="#7、-do-和-dp" class="headerlink" title="7、 do 和 dp"></a>7、 do 和 dp</h3><p>将光标所在不同区域同步为另一个文件该位置的内容 和 将光标所在不同区域内容同步到另一个文件该位置</p><h3 id="8、-diffu"><a href="#8、-diffu" class="headerlink" title="8、 :diffu[!]"></a>8、 :diffu[!]</h3><p>vim下更新当前比较窗口，比较状态下修改文件后，可调用该命令[中括号不为命令部分，如果加!表示如果外部修改了文件，则重新加载比较]</p><h3 id="9、-diffo"><a href="#9、-diffo" class="headerlink" title="9、 :diffo[!]"></a>9、 :diffo[!]</h3><p>vim下关闭当前窗口比较状态，如果加!则关闭所有窗口的比较状态</p><h3 id="10、-diffs-file1"><a href="#10、-diffs-file1" class="headerlink" title="10、:diffs file1"></a>10、:diffs file1</h3><p>vim下加入file1和当前光标所在窗口进行比较，水平分隔窗口</p><h3 id="11、-vert-diffs-file1"><a href="#11、-vert-diffs-file1" class="headerlink" title="11、:vert diffs file1"></a>11、:vert diffs file1</h3><p>vim下加入file1和当前光标所在窗口进行比较，垂直分隔窗口</p><h3 id="12、-difft"><a href="#12、-difft" class="headerlink" title="12、:difft"></a>12、:difft</h3><p>vim下将光标所在窗口变为比较窗口</p><p>##其它技巧：</p><h3 id="1、-diff-u-file1-file2-gt-file3"><a href="#1、-diff-u-file1-file2-gt-file3" class="headerlink" title="1、 diff -u file1 file2 &gt; file3"></a>1、 diff -u file1 file2 &gt; file3</h3><p>终端下输入该命令，可以将file1和file2的比较结果输出到file3中，-u 表示以合并格式比较，-c 为上下文格式，不加为一般格式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##实用的vim下比较两个文件命令：&lt;/p&gt;
&lt;h3 id=&quot;1、-vimdiff-file1-file2&quot;&gt;&lt;a href=&quot;#1、-vimdiff-file1-file2&quot; class=&quot;headerlink&quot; title=&quot;1、 vimdiff file1 file2&quot;&gt;&lt;/a&gt;1、 vimdiff file1 file2&lt;/h3&gt;&lt;p&gt;终端下输入该命令进入vim，垂直分隔窗口进行比较&lt;/p&gt;
&lt;h3 id=&quot;2、-vimdiff-o-file1-file2&quot;&gt;&lt;a href=&quot;#2、-vimdiff-o-file1-file2&quot; class=&quot;headerlink&quot; title=&quot;2、 vimdiff -o file1 file2&quot;&gt;&lt;/a&gt;2、 vimdiff -o file1 file2&lt;/h3&gt;&lt;p&gt;水平分隔窗口进行比较&lt;/p&gt;
&lt;h3 id=&quot;3、-ctrl-w-j-k-h-l&quot;&gt;&lt;a href=&quot;#3、-ctrl-w-j-k-h-l&quot; class=&quot;headerlink&quot; title=&quot;3、 ctrl+w (j,k,h,l)&quot;&gt;&lt;/a&gt;3、 ctrl+w (j,k,h,l)&lt;/h3&gt;&lt;p&gt;上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l）&lt;/p&gt;
&lt;h3 id=&quot;4、-ctrl-w-J-K-H-L&quot;&gt;&lt;a href=&quot;#4、-ctrl-w-J-K-H-L&quot; class=&quot;headerlink&quot; title=&quot;4、 ctrl+w (J,K,H,L)&quot;&gt;&lt;/a&gt;4、 ctrl+w (J,K,H,L)&lt;/h3&gt;&lt;p&gt;上下左右移动光标所在窗口的位置&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux-vimdiff" scheme="http://yoursite.com/tags/linux-vimdiff/"/>
    
  </entry>
  
  <entry>
    <title>linux查看系统命令</title>
    <link href="http://yoursite.com/2019/01/08/linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2019/01/08/linux系统信息查看/</id>
    <published>2019-01-08T06:22:53.000Z</published>
    <updated>2019-01-08T06:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>inux 查看系统信息命令是linux初学者必备的基础知识, 这些命令也非常有用, 因为进入linux第一件事就可能是首先查看系统信息, 因此必要的系统的学习一下这些linux系统信息命令还是非常有必要的!</p><a id="more"></a><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uname -a # 查看内核/操作系统/CPU信息 </span></span><br><span class="line"><span class="comment"># head -n 1 /etc/issue # 查看操作系统版本 </span></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo # 查看CPU信息 </span></span><br><span class="line"><span class="comment"># hostname # 查看计算机名 </span></span><br><span class="line"><span class="comment"># lspci -tv # 列出所有PCI设备 </span></span><br><span class="line"><span class="comment"># lsusb -tv # 列出所有USB设备 </span></span><br><span class="line"><span class="comment"># lsmod # 列出加载的内核模块 </span></span><br><span class="line"><span class="comment"># env # 查看环境变量资源 </span></span><br><span class="line"><span class="comment"># free -m # 查看内存使用量和交换区使用量 </span></span><br><span class="line"><span class="comment"># df -h # 查看各分区使用情况 </span></span><br><span class="line"><span class="comment"># du -sh &lt;目录名&gt; # 查看指定目录的大小 </span></span><br><span class="line"><span class="comment"># grep MemTotal /proc/meminfo # 查看内存总量 </span></span><br><span class="line"><span class="comment"># grep MemFree /proc/meminfo # 查看空闲内存量 </span></span><br><span class="line"><span class="comment"># uptime # 查看系统运行时间、用户数、负载 </span></span><br><span class="line"><span class="comment"># cat /proc/loadavg # 查看系统负载磁盘和分区 </span></span><br><span class="line"><span class="comment"># mount | column -t # 查看挂接的分区状态 </span></span><br><span class="line"><span class="comment"># fdisk -l # 查看所有分区 </span></span><br><span class="line"><span class="comment"># swapon -s # 查看所有交换分区 </span></span><br><span class="line"><span class="comment"># hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) </span></span><br><span class="line"><span class="comment"># dmesg | grep IDE # 查看启动时IDE设备检测状况网络 </span></span><br><span class="line"><span class="comment"># ifconfig # 查看所有网络接口的属性 </span></span><br><span class="line"><span class="comment"># iptables -L # 查看防火墙设置 </span></span><br><span class="line"><span class="comment"># route -n # 查看路由表 </span></span><br><span class="line"><span class="comment"># netstat -lntp # 查看所有监听端口 </span></span><br><span class="line"><span class="comment"># netstat -antp # 查看所有已经建立的连接 </span></span><br><span class="line"><span class="comment"># netstat -s # 查看网络统计信息进程 </span></span><br><span class="line"><span class="comment"># ps -ef # 查看所有进程 </span></span><br><span class="line"><span class="comment"># top # 实时显示进程状态用户 </span></span><br><span class="line"><span class="comment"># w # 查看活动用户 </span></span><br><span class="line"><span class="comment"># id &lt;用户名&gt; # 查看指定用户信息 </span></span><br><span class="line"><span class="comment"># last # 查看用户登录日志 </span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/passwd # 查看系统所有用户 </span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/group # 查看系统所有组 </span></span><br><span class="line"><span class="comment"># crontab -l # 查看当前用户的计划任务服务 </span></span><br><span class="line"><span class="comment"># chkconfig –list # 列出所有系统服务 </span></span><br><span class="line"><span class="comment"># chkconfig –list | grep on # 列出所有启动的系统服务程序 </span></span><br><span class="line"><span class="comment"># rpm -qa # 查看所有安装的软件包</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;inux 查看系统信息命令是linux初学者必备的基础知识, 这些命令也非常有用, 因为进入linux第一件事就可能是首先查看系统信息, 因此必要的系统的学习一下这些linux系统信息命令还是非常有必要的!&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac iTerm使用</title>
    <link href="http://yoursite.com/2018/12/20/iTerm%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/12/20/iTerm命令/</id>
    <published>2018-12-20T09:23:57.000Z</published>
    <updated>2018-12-20T09:23:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac iTerm终端使用</p><a id="more"></a><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>新建标签：command + t关闭标签：command + w切换标签：command + 数字 command + 左右方向键切换全屏：command + enter查找：command + f</code></pre><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><pre><code>垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键 command + [ 或 command + ]查看历史命令：command + ;查看剪贴板历史：command + shift + h</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>清除当前行：ctrl + u到行首：ctrl + a到行尾：ctrl + e前进后退：ctrl + f/b (相当于左右方向键)上一条命令：ctrl + p搜索命令历史：ctrl + r删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w删除到文本末尾：ctrl + k交换光标处文本：ctrl + t清屏1：command + r清屏2：ctrl + l</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac iTerm终端使用&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac iTerm" scheme="http://yoursite.com/tags/Mac-iTerm/"/>
    
  </entry>
  
  <entry>
    <title>erlang防坑指南</title>
    <link href="http://yoursite.com/2018/12/16/erlang%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/12/16/erlang防坑指南/</id>
    <published>2018-12-16T10:35:26.000Z</published>
    <updated>2018-12-16T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何语言在使用中都会遇到这样那样的问题，erlang也是。这里整理下我遇到的一些问题，避免继续踩坑。说实话，“防坑指南”这个标题有点过于标新立异，不过还是希望能引起重视，避免在实际开发中重复犯这些问题。<br><a id="more"></a></p><h3 id="‘–’-运算与-‘-’运算"><a href="#‘–’-运算与-‘-’运算" class="headerlink" title="‘–’ 运算与 ‘++’运算"></a>‘–’ 运算与 ‘++’运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1&gt; [1,2,3,4] -- [1] -- [2]. </span><br><span class="line">[2,3,4]</span><br><span class="line">算是erlang经典的问题了。这是从后面算起的，先算 [1] -- [2] ，得到 [1] 后被 [1,2,3,4] --，最后得到 [2,3,4]</span><br><span class="line"> &apos;++&apos;运算也是一样的，也是从后面开始算起。</span><br><span class="line">2&gt; [1,2,3,4] -- [1] ++ [2,3,4].</span><br><span class="line">[]</span><br><span class="line">另外，以下这种情况也要注意，只会减去遇到的第一个元素。</span><br><span class="line">3&gt; [1,2,3,2] -- [2].</span><br><span class="line">[1,3,2]</span><br></pre></td></tr></table></figure><h3 id="erlang-function-exported"><a href="#erlang-function-exported" class="headerlink" title="erlang:function_exported()"></a>erlang:function_exported()</h3><p>这个接口是用来检查模块函数是否导出，但是，如果模块没加载过，这个函数返回值就是false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3&gt; erlang:function_exported(odbc,start,0).</span><br><span class="line">false</span><br><span class="line">4&gt; odbc:start().</span><br><span class="line">ok</span><br><span class="line">5&gt; erlang:function_exported(odbc,start,0).</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="erlang-list-to-binary"><a href="#erlang-list-to-binary" class="headerlink" title="erlang:list_to_binary()"></a>erlang:list_to_binary()</h3><p>如果参数是多层嵌套结构，就会被扁平化掉，使用 binary_to_list 不能转成原来的数据，也就是不可逆的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6&gt; list_to_binary([1,2,[3,4],5]) .</span><br><span class="line">&lt;&lt;1,2,3,4,5&gt;&gt;</span><br><span class="line">如果想可逆，可以使用 erlang:term_to_binary</span><br><span class="line">7&gt; binary_to_term(term_to_binary([1,2,[3,4],5])).</span><br><span class="line">[1,2,[3,4],5]</span><br></pre></td></tr></table></figure><h3 id="random-uniform"><a href="#random-uniform" class="headerlink" title="random:uniform()"></a>random:uniform()</h3><p>这个用于生成随机数，返回一个随机数浮点数。但是，这个函数的随机初始种子是个定值，而且种子就放在进程字典，就是说每个进程生成的随机数都是一样的。坑爹啊。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end)</span><br><span class="line">,ok.</span><br><span class="line">0.4435846174457203 0.7230402056221108</span><br><span class="line">ok</span><br><span class="line">11&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end)</span><br><span class="line">,ok.</span><br><span class="line">0.4435846174457203 0.7230402056221108</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>所以，解决的方法就是进程启动后要重置随机数种子，然后再使用这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13&gt; random:seed(erlang:now()), random:uniform().</span><br><span class="line">0.4691405130019146</span><br></pre></td></tr></table></figure><h3 id="io-lib-char-list"><a href="#io-lib-char-list" class="headerlink" title="io_lib:char_list()"></a>io_lib:char_list()</h3><p>这个函数在R15和R16下运行结果可能是相反的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R15下：</span><br><span class="line">Eshell V5.9.3.1 (abort with ^G)</span><br><span class="line">1&gt; io_lib:char_list([10100,10600,20100]).</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">R16下：</span><br><span class="line">Eshell V5.10.1 (abort with ^G) </span><br><span class="line">1&gt; io_lib:char_list([10100,10600,20100]). </span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="不同类型数据比较"><a href="#不同类型数据比较" class="headerlink" title="不同类型数据比较"></a>不同类型数据比较</h3><p>比较公式为：number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</p><h3 id="系统限制"><a href="#系统限制" class="headerlink" title="系统限制"></a>系统限制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mnesia或dets有2G限制（无法定制）</span><br><span class="line">2. ets表最大数量默认1400（可用 ERL_MAX_ETS_TABLES 定制）</span><br><span class="line">3. 原子最大数量默认 1048576 （可用 +t 定制）</span><br><span class="line">4. 进程最大数量默认 32768   （可用  +P 定制， 范围1024-134217727）</span><br><span class="line">5. 端口/文件句柄最大数量默认 16384  （可用  +Q  定制， 范围1024-134217727）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何语言在使用中都会遇到这样那样的问题，erlang也是。这里整理下我遇到的一些问题，避免继续踩坑。说实话，“防坑指南”这个标题有点过于标新立异，不过还是希望能引起重视，避免在实际开发中重复犯这些问题。&lt;br&gt;
    
    </summary>
    
      <category term="开发语言" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="erlang" scheme="http://yoursite.com/tags/erlang/"/>
    
  </entry>
  
  <entry>
    <title>account</title>
    <link href="http://yoursite.com/2018/12/16/account/"/>
    <id>http://yoursite.com/2018/12/16/account/</id>
    <published>2018-12-16T10:35:26.000Z</published>
    <updated>2018-12-16T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码账号"><a href="#代码账号" class="headerlink" title="代码账号"></a>代码账号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:good-leaf</span><br><span class="line">mail:rwzgnyyj</span><br></pre></td></tr></table></figure><h3 id="软件账号"><a href="#软件账号" class="headerlink" title="软件账号"></a>软件账号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username:yangyajun-soft</span><br><span class="line">mail:yangyajun_c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码账号&quot;&gt;&lt;a href=&quot;#代码账号&quot; class=&quot;headerlink&quot; title=&quot;代码账号&quot;&gt;&lt;/a&gt;代码账号&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="self" scheme="http://yoursite.com/categories/self/"/>
    
    
      <category term="self" scheme="http://yoursite.com/tags/self/"/>
    
  </entry>
  
</feed>
