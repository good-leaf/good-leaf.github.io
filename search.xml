<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F19%2Frabbitmq%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1title: rabbitmq知识date: 2019-02-13 17:23:39categories: 组件tags: rabbitmq RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。 AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ介绍RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。 AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 交换机(Exchange)RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述） fanout 转发消息到所有绑定队列。 direct 把消息路由到那些binding key与routing key完全匹配的Queue中。 headers headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。 topic topic类型的Exchange在匹配规则上进行了扩展。 routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”。 binding key与routing key一样也是句点号“. ”分隔的字符串。 binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。 RabbitMQ RPC RabbitMQ 中实现RPC的机制是： 客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败） 服务器端收到消息并处理 服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性 客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理 RabbitMQ 选型和对比1.从社区活跃度 按照目前网络上的资料，RabbitMQ、activeM、ZeroMQ三者中，综合来看，RabbitMQ是首选。 2.持久化消息比较 ZeroMq不支持，ActiveMq和RabbitMq都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。 3.综合技术实现 可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。 RabbitMq/Kafka最好，ActiveMq次之，ZeroMq最差。当然ZeroMq也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。 4.高并发 毋庸置疑，RabbitMQ最高，原因是它的实现语言是天生具备高并发高可用的erlang语言。 5.比较关注的比较，RabbitMQ和 Kafka RabbitMq比Kafka成熟，在可用性上，稳定性上，可靠性上， RabbitMq 胜于 Kafka （理论上）。 另外，Kafka的定位主要在日志等方面， 因为Kafka设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择RabbitMq。 RabbitMQ Erlang ClientAmqp Erlang Client]]></content>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA使用]]></title>
    <url>%2F2019%2F02%2F13%2FIntellijIDEA%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关闭自动更新 Intellij IDEA -&gt; Preferences -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates 下取消 Automatically check updates for勾选 代码编辑器主题风格 Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Font 1234Scheme: DarculaShow only monospaced fonts 设置第一字体，Monaco 不支持中文 Primary font:Monaco Size:20 Line spacing:1.0Secondary font：YaHei Consolas Hybrid 设置第二字体 文件编码 File -&gt; Settings -&gt; Editor -&gt; File Encodings 1234Global Encoding:UTF-8Projectt Encoding:UTF-8Default encoding for properties files:UTF-8勾选上Transparent native-to-ascii conversion 类和方法注视模版 在File -&gt; Settings -&gt; Editor -&gt; File and Code Templates 编码缩进 Intellij IDEA -&gt; Preferences -&gt; Editor -&gt; Code Style -&gt; Erlang Use tab character 不要勾选，然后indent设置为4，代表按一个tab为4个空格，并且自动整理格式也是4个空格一缩进。 123Tab size: 4 Indent: 4Continuation indent: 8 如果要对多个文件进行转换，可以在文件夹上面按右键，然后点击Reformat Code或者选中文件夹按快捷键ctrl+alt+L对多个快捷键整理。]]></content>
      <categories>
        <category>development_tool</category>
      </categories>
      <tags>
        <tag>development_tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java安装]]></title>
    <url>%2F2019%2F02%2F13%2Fjava%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[java 1.8 安装 yum install yum install java-1.8.0-openjdk-devel.x86_64 java 环境变量 CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等； 1234PATH=$PATH:$HOME/binJAVA_HOME=/usr/lib/jvm/java-1.8.0CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jarPATH=$JAVA_HOME/bin:$HOME/bin:$HOME/.local/bin:$PATH java 1.8 安装 yum install yum install java-1.8.0-openjdk-devel.x86_64 java 环境变量 CLASSPATH中的tools.jar主要包含一些工具，如javac（将.java编译为.class）、javadoc（根据java源文件以html格式生成API文档）、javap（反汇编.class文件）等； 1234PATH=$PATH:$HOME/binJAVA_HOME=/usr/lib/jvm/java-1.8.0CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jarPATH=$JAVA_HOME/bin:$HOME/bin:$HOME/.local/bin:$PATH java 安装目录信息 dt.jar中包含了关于swing的控件对应的图标和BeanInfo.class 123456789101112/usr/lib/jvm-exports/java/usr/lib/java/usr/lib/jvm/java/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/jre/bin/java/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/bin/java/usr/share/java/usr/bin/java/var/lib/alternatives/java/etc/pki/java/etc/pki/ca-trust/extracted/java/etc/java/etc/alternatives/java]]></content>
      <categories>
        <category>develop-language</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp参数调优]]></title>
    <url>%2F2019%2F01%2F08%2Ftcp%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[/etc/sysctl.conf 1234567891011121314151617181920212223net.ipv4.tcp_tw_reuse = 1net.ipv4.ip_local_port_range = 1024 65535net.core.rmem_max=16777216net.core.wmem_max=16777216net.ipv4.tcp_rmem=4096 87380 16777216net.ipv4.tcp_wmem=4096 65536 16777216net.ipv4.tcp_fin_timeout = 10net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_timestamps = 0net.ipv4.tcp_window_scaling = 0net.ipv4.tcp_sack = 0net.core.netdev_max_backlog = 30000net.ipv4.tcp_no_metrics_save=1net.core.somaxconn = 262144net.ipv4.tcp_syncookies = 0net.ipv4.tcp_max_orphans = 262144net.ipv4.tcp_max_syn_backlog = 262144net.ipv4.tcp_synack_retries = 2net.ipv4.tcp_syn_retries = 2fs.file-max = 1024000net.nf_conntrack_max= 1024000net.ipv4.tcp_mem=786432 2097152 3145728 ulimit -a 中open files (-n) 1024000 修改 vi /etc/profile ulimit -n 1024000 生效：source /etc/profile cat /proc/sys/fs/file-max 修改：pending signals (-i) 128296 vi /etc/profile ulimit -i 128296 生效：source /etc/profile error, emfile 最大用户进程需要在90-nproc.conf vi /etc/security/limits.conf soft nofile 65535 hard nofile 65535 然后，一般来说，修改ulimit的数值，只需要修改/etc/security/limits.conf即可，但是这个参数需要修改/etc/security/limits.d/90-nproc.conf。centos 6.可以修改/etc/security/limits.d/90-nproc.conf，但centos 5.并没有90-nproc.conf这个文件，我这边是通过修改/etc/security/limits.conf。 netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ CLOSE_WAIT 162 ESTABLISHED 10163 SYN_RECV 242]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>sysctl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vimdiff]]></title>
    <url>%2F2019%2F01%2F08%2Fvimdiff%2F</url>
    <content type="text"><![CDATA[##实用的vim下比较两个文件命令： 1、 vimdiff file1 file2终端下输入该命令进入vim，垂直分隔窗口进行比较 2、 vimdiff -o file1 file2水平分隔窗口进行比较 3、 ctrl+w (j,k,h,l)上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l） 4、 ctrl+w (J,K,H,L) ##实用的vim下比较两个文件命令： 1、 vimdiff file1 file2终端下输入该命令进入vim，垂直分隔窗口进行比较 2、 vimdiff -o file1 file2水平分隔窗口进行比较 3、 ctrl+w (j,k,h,l)上下左右切换光标所在的窗口（括号中表示可以是其中之一，按下ctrl+w，放开ctrl再按j,k,h,l） 4、 ctrl+w (J,K,H,L)上下左右移动光标所在窗口的位置 5、 zo 和 zc打开折叠区 和 关闭折叠区 6、 ]c 和 [c将光标移动到下一个不同区 和 上一个不同区 7、 do 和 dp将光标所在不同区域同步为另一个文件该位置的内容 和 将光标所在不同区域内容同步到另一个文件该位置 8、 :diffu[!]vim下更新当前比较窗口，比较状态下修改文件后，可调用该命令[中括号不为命令部分，如果加!表示如果外部修改了文件，则重新加载比较] 9、 :diffo[!]vim下关闭当前窗口比较状态，如果加!则关闭所有窗口的比较状态 10、:diffs file1vim下加入file1和当前光标所在窗口进行比较，水平分隔窗口 11、:vert diffs file1vim下加入file1和当前光标所在窗口进行比较，垂直分隔窗口 12、:difftvim下将光标所在窗口变为比较窗口 ##其它技巧： 1、 diff -u file1 file2 &gt; file3终端下输入该命令，可以将file1和file2的比较结果输出到file3中，-u 表示以合并格式比较，-c 为上下文格式，不加为一般格式]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vimdiff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux查看系统命令]]></title>
    <url>%2F2019%2F01%2F08%2Flinux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[inux 查看系统信息命令是linux初学者必备的基础知识, 这些命令也非常有用, 因为进入linux第一件事就可能是首先查看系统信息, 因此必要的系统的学习一下这些linux系统信息命令还是非常有必要的! 12345678910111213141516171819202122232425262728293031323334353637# uname -a # 查看内核/操作系统/CPU信息 # head -n 1 /etc/issue # 查看操作系统版本 # cat /proc/cpuinfo # 查看CPU信息 # hostname # 查看计算机名 # lspci -tv # 列出所有PCI设备 # lsusb -tv # 列出所有USB设备 # lsmod # 列出加载的内核模块 # env # 查看环境变量资源 # free -m # 查看内存使用量和交换区使用量 # df -h # 查看各分区使用情况 # du -sh &lt;目录名&gt; # 查看指定目录的大小 # grep MemTotal /proc/meminfo # 查看内存总量 # grep MemFree /proc/meminfo # 查看空闲内存量 # uptime # 查看系统运行时间、用户数、负载 # cat /proc/loadavg # 查看系统负载磁盘和分区 # mount | column -t # 查看挂接的分区状态 # fdisk -l # 查看所有分区 # swapon -s # 查看所有交换分区 # hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) # dmesg | grep IDE # 查看启动时IDE设备检测状况网络 # ifconfig # 查看所有网络接口的属性 # iptables -L # 查看防火墙设置 # route -n # 查看路由表 # netstat -lntp # 查看所有监听端口 # netstat -antp # 查看所有已经建立的连接 # netstat -s # 查看网络统计信息进程 # ps -ef # 查看所有进程 # top # 实时显示进程状态用户 # w # 查看活动用户 # id &lt;用户名&gt; # 查看指定用户信息 # last # 查看用户登录日志 # cut -d: -f1 /etc/passwd # 查看系统所有用户 # cut -d: -f1 /etc/group # 查看系统所有组 # crontab -l # 查看当前用户的计划任务服务 # chkconfig –list # 列出所有系统服务 # chkconfig –list | grep on # 列出所有启动的系统服务程序 # rpm -qa # 查看所有安装的软件包]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[erlang知识点记录]]></title>
    <url>%2F2019%2F01%2F08%2Ferlang%20%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[gen_server:cast和erlang:send()都可以向指定进程发送消息，两者有什么区别？ gen_server:cast 内部调用erlang:send使用noconnect 123456case catch erlang:send(Dest, Msg, [noconnect]) of noconnect -&gt; spawn(erlang, send, [Dest,Msg]); Other -&gt; Other end. 12345-spec erlang:send(Dest, Msg, Options) -&gt; Res when Dest :: dst(), Msg :: term(), Options :: [nosuspend | noconnect], Res :: ok | nosuspend | noconnect. nosuspend：遇到会挂起进程时不挂起进程，直接返回nosuspend noconnect：遇到远程节点没有连接时不自动连接发送消息，直接返回noconnect gen_server:call rpc:call和gen_server:call 区别？ rpc模块本身就是gen_server进程，随kernel模块启动，rpc进程启动时通过local注册一个rex的名字。 rpc:call内部调用gen_server:call({Name,Node},Request)，Name是rex，所以说rpc:call是调用远程节点的rex进程做事情，而gen_server:call可以调用任意进程做事情。 erlang:now()和os:timestamp()区别？ erlang:now()获取erlang虚拟机时间，os:timestamp()获取操作系统时间，对于erlang:start_time函数如果调快系统时间，此定时不会提前收到消息。因为erlang:start_time内部使用erlang虚拟机时间。 erlang:send_after和erlang:start_time区别？ 主要是TimerRef，超时消息进入邮箱时，start_time函数的消息携带了TimeRef标识。 ref数据类型 Erlang 虚拟机会创建一个新的 ref。由于全局当前 ref 值是用多个变量表示的，所以 make_ref() 会通过一个自旋锁保护对这些变量的操作，递增全局 ref 的值，然后根据新的 ref 值创建新的 ref 对象并返回对应的 Eterm。递增操作针对 word 0 递增，如果 word 0 超过了218218，则进位到 word 1，word 1 归零的话则进位到 word 2。 我们打印 ref 的时候，得到的是类似 #Ref&lt;0.0.0.2055&gt; 这样的输出，通过 3 个句点将输出结果分为 4 段。第 1 段，和 pid 和 port 的第一段是一样的，表示节点，在本地节点总是为 0，后面 3 段分别为上面的 word 2、1 和 0。所以 ref 较少的时候前面几段都为 0。 ets表 123456789101112-spec new(Name, Options) -&gt; tid() | atom() when Name :: atom(), Options :: [Option], Option :: Type | Access | named_table | &#123;keypos,Pos&#125; | &#123;heir, Pid :: pid(), HeirData&#125; | &#123;heir, none&#125; | Tweaks, Type :: type(), Access :: access(), Tweaks :: &#123;write_concurrency, boolean()&#125; | &#123;read_concurrency, boolean()&#125; | compressed, Pos :: pos_integer(), HeirData :: term(). write_concurrency、read_concurrency是用来提升读写性能的，代价是额外的内存。并不是支持读和写的并发控制的，因为ets本身的读写操作就是原子的。通常来说，ets写数据时整张表是锁定的，其他进程不能进行读写直到前面的操作完成。并发写可以改变这个情况，同一个表中的不同记录可以被多个进程并发读写。有了这个参数，使得ets写记录时表读写锁变成了读锁，就是说，只要不是同一条记录，还可以继续往这个ets表写入数据，提高了并发写效率。但并发写也有弊端，降低数据连续写入的效率和性能。如果有且只有一个进程在读写数据，将会带来一定的开销。而测试发现这个开销比较小，可以忽略。而且，只有一个进程在读写数据的场合比较小。 Pid &lt;A,B,C&gt; A对应节点信息（0代表本地节点，其他数字代表远程节点） B低15字节代表进程表索引 C16～18字节代表进程唯一标识 erlang:dbg、trace、火焰图 receive的理解 receive会检查遍历进程的邮箱一次，如果匹配到条件，就执行条件后的代码，并去掉邮箱中对应消息，停止匹配过程。等待下一条消息到达时触发再次匹配逻辑。]]></content>
      <categories>
        <category>develop-language</category>
      </categories>
      <tags>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sysctl.conf调整]]></title>
    <url>%2F2019%2F01%2F08%2Flinux-sysctl%E8%B0%83%E6%95%B4%2F</url>
    <content type="text"><![CDATA[设置tcp参数一定要小心谨慎,轻易不要更改线上环境。 123456et.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_fin_timeout = 30 net.ipv4.tcp_keepalive_time = 1800 net.ipv4.tcp_max_syn_backlog = 4096 net.ipv4.tcp_syncookies = 1 www.2cto.com 执行 /sbin/sysctl -p 让参数生效。 大量TIME_WAIT问题 根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证. 解决方案： net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout 修改系統默认的 TIMEOUT 时间。 参数说明 tcp_syn_retries ：INTEGER 默认值是5 对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。不应该大于255，默认值是5，对应于180秒左右时间。(对于大负载而物理通信良好的网络而言,这个值偏高,可修改为2.这个值仅仅是针对对外的连接,对进来的连接,是由tcp_retries1 决定的) tcp_synack_retries ：INTEGER 默认值是5 对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。(可以根据上面的tcp_syn_retries来决定这个值) tcp_keepalive_time ：INTEGER 默认值是7200(2小时) 当keepalive打开的情况下，TCP发送keepalive消息的频率。(由于目前网络攻击等因素,造成了利用这个进行的攻击很频繁,曾经也有cu的朋友提到过,说如果2边建立了连接,然后不发送任何数据或者rst/fin消息,那么持续的时间是不是就是2小时,空连接攻击?tcp_keepalive_time就是预防此情形的.我个人在做nat服务的时候的修改值为1800秒) tcp_keepalive_probes：INTEGER 默认值是9 TCP发送keepalive探测以确定该连接已经断开的次数。(注意:保持连接仅在SO_KEEPALIVE套接字选项被打开是才发送.次数默认不需要修改,当然根据情形也可以适当地缩短此值.设置为5比较合适) tcp_keepalive_intvl：INTEGER 默认值为75 探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒，也就是没有活动的连接将在大约11分钟以后将被丢弃。(对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值) tcp_retries1 ：INTEGER 默认值是3 放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接) tcp_retries2 ：INTEGER 默认值为15 在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5) tcp_orphan_retries ：INTEGER 默认值是7 在近端丢弃TCP连接之前﹐要进行多少次重试。默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans 。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3) tcp_fin_timeout ：INTEGER 默认值是 60 对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒。 过去在2.2版本的内核中是 180 秒。您可以设置该值﹐但需要注意﹐如果您的机器为负载很重的web服务器﹐您可能要冒内存被大量无效数据报填满的风险﹐FIN-WAIT-2 sockets 的危险性低于 FIN-WAIT-1 ﹐因为它们最多只吃 1.5K 的内存﹐但是它们存在时间更长。另外参考 tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为30) tcp_max_tw_buckets ：INTEGER 默认值是180000 系统在同时所处理的最大 timewait sockets 数目。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要人为的降低这个限制﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值) tcp_tw_recycle ：BOOLEAN 默认值是0 打开快速 TIME-WAIT sockets 回收。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它) tcp_tw_reuse：BOOLEAN 默认值是0 该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助) tcp_max_orphans ：INTEGER 缺省值是8192 系统所能处理不属于任何进程的TCP sockets最大数量。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000) tcp_abort_on_overflow ：BOOLEAN 缺省值是0 当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它) tcp_syncookies ：BOOLEAN 默认值是0 只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。 注意：该选项千万不能用于那些没有收到攻击的高负载服务器，如果在日志中出现synflood消息，但是调查发现没有收到synflood攻击，而是合法用户的连接负载过高的原因，你应该调整其它参数来提高服务器性能。参考: tcp_max_syn_backlog tcp_synack_retries tcp_abort_on_overflow syncookie严重的违背TCP协议，不允许使用TCP扩展，可能对某些服务导致严重的性能影响(如SMTP转发)。(注意,该实现与BSD上面使用的tcp proxy一样,是违反了RFC中关于tcp连接的三次握手实现的,但是对于防御syn-flood的确很有用.) tcp_stdurg ：BOOLEAN 默认值为0 使用 TCP urg pointer 字段中的主机请求解释功能。大部份的主机都使用老旧的 BSD解释，因此如果您在Linux打开它﹐或会导致不能和它们正确沟通。 tcp_max_syn_backlog ：INTEGER 对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目。对于超过 128Mb 内存的系统﹐默认值是1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于1024﹐最好修改 include/net/tcp.h 里面的 TCP_SYNQ_HSIZE ﹐以保持TCP_SYNQ_HSIZE*16&lt;=tcp_max_syn_backlog ﹐并且编进核心之内。(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗 尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完 全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有 效的缓解小规模的SYN Flood攻击(事实证明&lt;1000p/s)加大SYN队列长度可以容纳更多等待连接的网络连接数，所以对Server来说可以考虑增大该值.) tcp_window_scaling ：INTEGER 缺省值为1 该文件表示设置tcp/ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0） tcp_timestamps ：BOOLEAN 缺省值为1 Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。) tcp_sack ：BOOLEAN 缺省值为1 使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。) tcp_fack ：BOOLEAN 缺省值为1 打开FACK拥塞避免和快速重传功能。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效) tcp_dsack ：BOOLEAN 缺省值为1 允许TCP发送”两个完全相同”的SACK。 tcp_ecn ：BOOLEAN 缺省值为0 打开TCP的直接拥塞通告功能。 tcp_reordering ：INTEGER 默认值是3 TCP流中重排序的数据报最大数量 。 (一般有看到推荐把这个数值略微调整大一些,比如5) tcp_retrans_collapse ：BOOLEAN 缺省值为1 对于某些有bug的打印机提供针对其bug的兼容性。(一般不需要这个支持,可以关闭它) tcp_wmem(3个INTEGER变量)： min, default, max min：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。 default：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。 max: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800） tcp_rmem (3个INTEGER变量)： min, default, max min：为TCP socket预留用于接收缓冲的内存数量，即使在内存出现紧张情况下tcp socket都至少会有这么多数量的内存用于接收缓冲，默认值为8K。 default：为TCP socket预留用于接收缓冲的内存数量，默认情况下该值影响其它协议使用的net.core.wmem_default 值。该值决定了在tcp_adv_win_scale、tcp_app_win和tcp_app_win=0默认值情况下，TCP窗口大小为65535。默认值为87380 max：用于TCP socket接收缓冲的内存最大值。该值不会影响 net.core.wmem_max，”静态”选择参数 SO_SNDBUF则不受该值影响。默认值为 128K。默认值为87380*2 bytes。（可以看出，.max的设置最好是default的两倍,对于NAT来说主要该增加它,我的网络里为 51200 131072 204800） tcp_mem(3个INTEGER变量)：low, pressure, high low：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 * 300 / 4096)。 ) pressure：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 * 300 / 4096)。 ) high：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 * 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000) 一般情况下这些值是在系统启动时根据系统内存数量计算得到的。 tcp_app_win : INTEGER 默认值是31 保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲。当为0时表示不需要缓冲。 tcp_adv_win_scale : INTEGER 默认值为2 计算缓冲开销bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale &lt;= 0）。 tcp_rfc1337 :BOOLEAN 缺省值为0 这个开关可以启动对于在RFC1337中描述的”tcp 的time-wait暗杀危机”问题的修复。启用后，内核将丢弃那些发往time-wait状态TCP套接字的RST 包. tcp_low_latency : BOOLEAN 缺省值为0 允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用。(但在构建Beowulf 集群的时候,打开它很有帮助) tcp_westwood :BOOLEAN 缺省值为0 启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项。 tcp_bic :BOOLEAN 缺省值为0 为快速长距离网络启用 Binary Increase Congestion；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>sysctl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac iTerm使用]]></title>
    <url>%2F2018%2F12%2F20%2FiTerm%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Mac iTerm终端使用 标签新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键 command + [ 或 command + ] 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 其他清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：command + r 清屏2：ctrl + l]]></content>
      <categories>
        <category>Mac iTerm</category>
      </categories>
      <tags>
        <tag>Mac iTerm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[account]]></title>
    <url>%2F2018%2F12%2F16%2Faccount%2F</url>
    <content type="text"><![CDATA[代码账号12username:good-leafmail:rwzgnyyj 软件账号12username:yangyajun-softmail:yangyajun_c]]></content>
      <categories>
        <category>self</category>
      </categories>
      <tags>
        <tag>self</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[erlang 防坑指南]]></title>
    <url>%2F2018%2F12%2F16%2Ferlang%E9%98%B2%E5%9D%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[任何语言在使用中都会遇到这样那样的问题，erlang也是。这里整理下我遇到的一些问题，避免继续踩坑。说实话，“防坑指南”这个标题有点过于标新立异，不过还是希望能引起重视，避免在实际开发中重复犯这些问题。 title: erlang防坑指南date: 2019-01-08 14:22:53updated: 2019-01-08 14:22:53categories: develop-language tags: erlang‘–’ 运算与 ‘++’运算1234567891&gt; [1,2,3,4] -- [1] -- [2]. [2,3,4]算是erlang经典的问题了。这是从后面算起的，先算 [1] -- [2] ，得到 [1] 后被 [1,2,3,4] --，最后得到 [2,3,4] &apos;++&apos;运算也是一样的，也是从后面开始算起。2&gt; [1,2,3,4] -- [1] ++ [2,3,4].[]另外，以下这种情况也要注意，只会减去遇到的第一个元素。3&gt; [1,2,3,2] -- [2].[1,3,2] erlang:function_exported()这个接口是用来检查模块函数是否导出，但是，如果模块没加载过，这个函数返回值就是false 1234563&gt; erlang:function_exported(odbc,start,0).false4&gt; odbc:start().ok5&gt; erlang:function_exported(odbc,start,0).true erlang:list_to_binary()如果参数是多层嵌套结构，就会被扁平化掉，使用 binary_to_list 不能转成原来的数据，也就是不可逆的。 123456&gt; list_to_binary([1,2,[3,4],5]) .&lt;&lt;1,2,3,4,5&gt;&gt;如果想可逆，可以使用 erlang:term_to_binary7&gt; binary_to_term(term_to_binary([1,2,[3,4],5])).[1,2,[3,4],5] random:uniform()这个用于生成随机数，返回一个随机数浮点数。但是，这个函数的随机初始种子是个定值，而且种子就放在进程字典，就是说每个进程生成的随机数都是一样的。坑爹啊。 1234567810&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end),ok.0.4435846174457203 0.7230402056221108ok11&gt; spawn(fun() -&gt; io:format(&quot;~w ~w~n&quot;,[random:uniform(),random:uniform()]) end),ok.0.4435846174457203 0.7230402056221108ok 所以，解决的方法就是进程启动后要重置随机数种子，然后再使用这个函数。 1213&gt; random:seed(erlang:now()), random:uniform().0.4691405130019146 io_lib:char_list()这个函数在R15和R16下运行结果可能是相反的。 123456789R15下：Eshell V5.9.3.1 (abort with ^G)1&gt; io_lib:char_list([10100,10600,20100]).falseR16下：Eshell V5.10.1 (abort with ^G) 1&gt; io_lib:char_list([10100,10600,20100]). true 不同类型数据比较比较公式为：number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string 系统限制123451. mnesia或dets有2G限制（无法定制）2. ets表最大数量默认1400（可用 ERL_MAX_ETS_TABLES 定制）3. 原子最大数量默认 1048576 （可用 +t 定制）4. 进程最大数量默认 32768 （可用 +P 定制， 范围1024-134217727）5. 端口/文件句柄最大数量默认 16384 （可用 +Q 定制， 范围1024-134217727）]]></content>
      <categories>
        <category>erlang</category>
      </categories>
      <tags>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq安装]]></title>
    <url>%2F2018%2F12%2F14%2Frabbitmq%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[版本：rabbitmq-server-3.6.6-1.el6.noarch.rpm 1234567891011121314151617181920212223242526sudo sucd /tmp &amp;&amp; wget https://yangyajun-soft.github.io/rabbitmq3.6.6/rabbitmq-server-3.6.6-1.el6.noarch.rpmyum install -y rabbitmq-server-3.6.6-1.el6.noarch.rpmchown rabbitmq:rabbitmq /etc/rabbitmqexit# set cookiesudo su rabbitmqecho cookie &gt; /var/lib/rabbitmq/.erlang.cookiechmod u=r,g=,o= /var/lib/rabbitmq/.erlang.cookiewget https://yangyajun-soft.github.io//rabbitmq3.6.6/rabbitmq.config -O /etc/rabbitmq/rabbitmq.config# startrabbitmq-server -detached# join clusterrabbitmqctl stop_apprabbitmqctl join_cluster rabbit@hostrabbitmqctl start_app# configrabbitmqctl set_policy ha-backup "^" '&#123;"ha-mode":"exactly", "ha-params":2, "ha-sync-mode":"automatic"&#125;'rabbitmq-plugins enable rabbitmq_management# add adminrabbitmqctl add_user admin passwordrabbitmqctl set_permissions -p "/" admin '.*' '.*' '.*'rabbitmqctl set_user_tags admin administrator# add userrabbitmqctl add_user user passwordrabbitmqctl set_permissions -p "/" user '.*' '.*' '.*']]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 安装]]></title>
    <url>%2F2018%2F12%2F14%2Fhexo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[git设置12git config --global user.name "good-leaf"git config --global user.email "rwzgnyyj@xxx.com" hexo安装1234567npm install -g hexo-clicdhexo init blogcd blognpm installhexo servernpm install --save hexo-deployer-git hexo配置添加git地址：使用ssh时，需要将本机ssh key添加到github上，并且选择ssh访问方式。 1234deploy: type: git repo: git@github.com:good-leaf/good-leaf.github.io.git branch: master 修改端口：vi _config.yml 1234server: port: 4001 compress: true header: true 搜索支持： 1234567npm install hexo-generator-searchdb --savesearch: path: search.xml field: post format: html limit: 10000 更换主题：访问页面显示123456789101112extends partial/layoutblock container include mixins/post +posts()block pagination include mixins/paginator +home()block copyright include partial/copyright 解决：npm install –save hexo-renderer-jade]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis安装]]></title>
    <url>%2F2018%2F12%2F14%2Fredis%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[版本：redis-3.2.8-1.el6.remi.x86_64.rpm 123456789101112131415161718sudo sucd /tmp &amp;&amp; wget https://yangyajun-soft.github.io/redis/redis-3.2.8-1.el6.remi.x86_64.rpmyum install -y redis-3.2.8-1.el6.remi.x86_64.rpmsu sankuaimkdir -p /opt/xxx/apps/rediscd /opt/xxx/apps/redis## 6379mkdir -p /opt/xxx/appdatas/redis6379wget https://yangyajun-soft.github.io/redis/redis_6379_3.conf -O 6379.confredis-server /opt/xxx/apps/redis/6379.conf## 6380mkdir -p /opt/xxx/appdatas/redis6380wget https://yangyajun-soft.github.io/redis/redis_6380_3.conf -O 6380.conf## 6381mkdir -p /opt/xxx/appdatas/redis6381wget https://yangyajun-soft.github.io/redis/redis_6381_3.conf -O 6381.confexitexit]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
